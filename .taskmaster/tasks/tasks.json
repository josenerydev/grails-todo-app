{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Configurar Ambiente do Projeto e Dependências com MySQL via Docker Compose",
        "description": "Garantir que o projeto Grails 2.5.6 esteja configurado corretamente, incluindo MySQL via Docker Compose para o ambiente de desenvolvimento, e verificar que Bootstrap 3 e jQuery estejam integrados adequadamente no layout principal.",
        "status": "todo",
        "dependencies": [],
        "priority": "high",
        "details": "1.  **Verificar e Atualizar `grails-app/conf/BuildConfig.groovy`:**\n    *   Confirmar que a versão do Grails é 2.5.6.\n    *   Adicionar a dependência do driver MySQL JDBC no bloco `dependencies` (se não estiver presente). Exemplo:\n        ```groovy\n        // grails-app/conf/BuildConfig.groovy\n        dependencies {\n            // ... outras dependências\n            runtime 'mysql:mysql-connector-java:5.1.36' // Versão compatível com Grails 2.5.6 e MySQL 8.0\n        }\n        ```\n    *   Verificar a presença de plugins ou configurações relacionadas a Bootstrap 3 e jQuery, embora para Grails 2.5.6, eles sejam geralmente incluídos diretamente no GSP.\n\n2.  **Configurar `grails-app/conf/DataSource.groovy` para MySQL no ambiente `development`:**\n    *   Atualizar o bloco `dataSource` para o ambiente `development` para usar MySQL. Exemplo:\n        ```groovy\n        // grails-app/conf/DataSource.groovy\n        environments {\n            development {\n                dataSource {\n                    dbCreate = \"update\" // ou \"create-drop\" para desenvolvimento\n                    url = \"jdbc:mysql://localhost:3306/todoapi_dev?useSSL=false&autoReconnect=true\"\n                    driverClassName = \"com.mysql.jdbc.Driver\"\n                    username = \"devuser\"\n                    password = \"devpassword\"\n                    properties {\n                        jmxEnabled = true\n                        initialSize = 5\n                        maxActive = 50\n                        minEvictableIdleTimeMillis = 1800000\n                        timeBetweenEvictionRunsMillis = 1800000\n                        numTestsPerEvictionRun = 3\n                        testOnBorrow = true\n                        testWhileIdle = true\n                        testOnReturn = false\n                        validationQuery = \"SELECT 1\"\n                    }\n                }\n            }\n            // ... outros ambientes\n        }\n        ```\n    *   Garantir que `dbCreate` esteja configurado para `update` ou `create-drop` para facilitar o desenvolvimento.\n\n3.  **Criar `docker-compose.yml` para o serviço MySQL:**\n    *   Para os detalhes completos da criação e configuração do `docker-compose.yml` com MySQL 8.0, consulte a **Tarefa 16: Configurar Docker Compose com MySQL para Desenvolvimento**. Esta tarefa deve garantir que o arquivo `docker-compose.yml` seja criado na raiz do projeto, definindo um serviço `db` com a imagem `mysql:8.0`, portas mapeadas, variáveis de ambiente (`MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE`, `MYSQL_USER`, `MYSQL_PASSWORD`) e um volume nomeado para persistência de dados.\n\n4.  **Verificar `grails-app/views/layouts/main.gsp` para inclusões de Bootstrap 3 e jQuery:**\n    *   Confirmar que os arquivos CSS do Bootstrap 3 e os arquivos JavaScript do jQuery estão corretamente linkados. Exemplo de inclusão esperada:\n        ```html\n        <%-- grails-app/views/layouts/main.gsp --%>\n        <head>\n            ...\n            <link rel=\"stylesheet\" href=\"${resource(dir: 'css', file: 'bootstrap.min.css')}\" type=\"text/css\">\n            ...\n        </head>\n        <body>\n            ...\n            <g:javascript library=\"jquery\"/> <%-- Grails 2.x geralmente inclui jQuery desta forma --%>\n            <script src=\"${resource(dir: 'js', file: 'bootstrap.min.js')}\"></script>\n            ...\n        </body>\n        ```\n    *   Verificar se os arquivos `bootstrap.min.css`, `bootstrap.min.js` e `jquery-x.x.x.min.js` (ou similar) estão presentes nos diretórios `web-app/css` e `web-app/js` respectivamente, ou se estão sendo carregados via CDN.\n\n5.  **Criar `HomeController` e `index.gsp` (se não existirem):**\n    *   Criar `grails-app/controllers/todoapi/HomeController.groovy` com um método `index` básico:\n        ```groovy\n        // grails-app/controllers/todoapi/HomeController.groovy\n        package todoapi\n\n        class HomeController {\n            def index() {\n                render(view: 'index')\n            }\n        }\n        ```\n    *   Criar `grails-app/views/home/index.gsp` com um conteúdo HTML básico para testar o layout:\n        ```html\n        <%-- grails-app/views/home/index.gsp --%>\n        <!doctype html>\n        <html>\n            <head>\n                <meta name=\"layout\" content=\"main\">\n                <title>Bem-vindo ao Todo API</title>\n            </head>\n            <body>\n                <div class=\"container\">\n                    <div class=\"jumbotron\">\n                        <h1>Bem-vindo!</h1>\n                        <p>Seu projeto Grails 2.5.6 está configurado com Bootstrap 3 e jQuery.</p>\n                        <p><a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\">Saiba mais</a></p>\n                    </div>\n                </div>\n            </body>\n        </html>\n        ```\n    *   Verificar ou configurar `grails-app/conf/UrlMappings.groovy` para mapear a URL raiz (`/`) para `HomeController.index`. Exemplo:\n        ```groovy\n        // grails-app/conf/UrlMappings.groovy\n        class UrlMappings {\n            static mappings = {\n                \"/$controller/$action?/$id?(.$format)?\"{\n                    constraints {\n                        // apply constraints here\n                    }\n                }\n                \"/\"(controller: \"home\", action:\"index\") // Mapeia a raiz para HomeController.index\n                \"500\"(view:'/error')\n            }\n        }\n        ```",
        "testStrategy": "1.  **Iniciar o serviço MySQL via Docker Compose:**\n    *   Execute `docker-compose up -d` a partir da raiz do projeto.\n    *   Verifique se o container MySQL está rodando com `docker ps`.\n    *   Para mais detalhes sobre a verificação do Docker Compose, consulte a **Tarefa 16: Configurar Docker Compose com MySQL para Desenvolvimento**.\n\n2.  **Executar a aplicação Grails:**\n    *   Execute `grails run-app`.\n\n3.  **Verificar a conexão com o banco de dados MySQL:**\n    *   Monitore os logs do Grails no console para mensagens de conexão bem-sucedida com o MySQL (ex: \"Connected to jdbc:mysql://localhost:3306/todoapi_dev\").\n    *   Opcionalmente, crie uma entidade de domínio simples (ex: `Task.groovy`) e tente persistir uma instância para confirmar a escrita no banco de dados.\n\n4.  **Acessar a aplicação no navegador e verificar o frontend:**\n    *   Abra o navegador e acesse `http://localhost:8080/todo-api` (ou `http://localhost:8080/` se o contexto for configurado para a raiz).\n    *   Verifique se a página de boas-vindas (`index.gsp` do `HomeController`) carrega corretamente.\n    *   Inspecione os elementos da página para confirmar que o Bootstrap 3 está aplicando os estilos (ex: botões com classes `btn btn-primary`).\n    *   Abra o console do navegador e execute `jQuery.fn.jquery` para verificar a versão do jQuery carregada. Execute um comando simples como `$('.jumbotron').length` para confirmar que jQuery está funcionando.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implementar Classe de Domínio Task e Enums",
        "description": "Criar a classe de domínio `Task` com todos os campos especificados (título, descrição, status, prioridade, dataCriacao, ultimaAtualizacao) e suas restrições. Também definir os enums `TaskStatus` e `TaskPriority`.",
        "status": "todo",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create `grails-app/domain/todoapi/Task.groovy` with `title` (blank: false, maxSize: 255), `description` (nullable: true, maxSize: 1000), `status` (default PENDING), `priority` (default MEDIUM), `dateCreated`, `lastUpdated`. Create `src/groovy/todoapi/TaskStatus.groovy` (PENDING, COMPLETED) and `src/groovy/todoapi/TaskPriority.groovy` (LOW, MEDIUM, HIGH).",
        "testStrategy": "Write unit tests for `Task` domain class to verify constraints and default values. Test enum definitions.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TaskStatus Enum",
            "description": "Create the `TaskStatus` enum in `src/groovy/todoapi/TaskStatus.groovy` with `PENDING` and `COMPLETED` values.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `src/groovy/todoapi/TaskStatus.groovy` and define the enum with `PENDING` and `COMPLETED` members.\n<info added on 2025-09-24T21:54:38.549Z>\nTítulo da subtarefa atualizado para: Criar Enum TaskStatus.\nDescrição da subtarefa atualizada para: Criar o enum `TaskStatus` em `src/groovy/todoapi/TaskStatus.groovy` com os valores `PENDING` e `COMPLETED`.\n</info added on 2025-09-24T21:54:38.549Z>",
            "testStrategy": "Verify `TaskStatus.groovy` exists and contains `PENDING` and `COMPLETED` members. Can be done by simple compilation or a basic unit test asserting enum values."
          },
          {
            "id": 2,
            "title": "Create TaskPriority Enum",
            "description": "Create the `TaskPriority` enum in `src/groovy/todoapi/TaskPriority.groovy` with `LOW`, `MEDIUM`, and `HIGH` values.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `src/groovy/todoapi/TaskPriority.groovy` and define the enum with `LOW`, `MEDIUM`, and `HIGH` members.\n<info added on 2025-09-24T21:54:48.838Z>\ntitle: Criar Enum TaskPriority\ndescription: Criar o enum `TaskPriority` em `src/groovy/todoapi/TaskPriority.groovy` com os valores `LOW`, `MEDIUM` e `HIGH`.\n</info added on 2025-09-24T21:54:48.838Z>\n<info added on 2025-09-24T22:09:47.428Z>\ntitle: Criar Enum TaskPriority\ndescription: Criar o enum `TaskPriority` em `src/groovy/todoapi/TaskPriority.groovy` com os valores `LOW`, `MEDIUM` e `HIGH`.\n</info added on 2025-09-24T22:09:47.428Z>",
            "testStrategy": "Verify `TaskPriority.groovy` exists and contains `LOW`, `MEDIUM`, `HIGH` members. Can be done by simple compilation or a basic unit test asserting enum values."
          },
          {
            "id": 3,
            "title": "Create Task Domain Class File and Basic Fields",
            "description": "Create the `Task.groovy` file in `grails-app/domain/todoapi/` and define the basic `title` and `description` fields as `String`.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `grails-app/domain/todoapi/Task.groovy` and declare `String title` and `String description` fields.\n<info added on 2025-09-24T21:54:51.146Z>\nCriar Arquivo da Classe de Domínio Task e Campos Básicos\" - \"Criar o arquivo `Task.groovy` em `grails-app/domain/todoapi/` e definir os campos básicos `title` e `description` como `String`.\n</info added on 2025-09-24T21:54:51.146Z>\n<info added on 2025-09-24T22:09:52.744Z>\nCriar Arquivo da Classe de Domínio Task e Campos Básicos\" - \"Criar o arquivo `Task.groovy` em `grails-app/domain/todoapi/` e definir os campos básicos `title` e `description` como `String`.\n</info added on 2025-09-24T22:09:52.744Z>",
            "testStrategy": "Verify `Task.groovy` exists in the correct path and declares `title` and `description` as `String` fields."
          },
          {
            "id": 4,
            "title": "Add Enum Fields and GORM Timestamps to Task Domain Class",
            "description": "Add `status` (type `TaskStatus`) and `priority` (type `TaskPriority`) fields to `Task.groovy`. Also, declare `dateCreated` and `lastUpdated` fields, leveraging GORM's automatic timestamping. [Updated: 9/24/2025]",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In `grails-app/domain/todoapi/Task.groovy`, add `TaskStatus status`, `TaskPriority priority`, `Date dateCreated`, and `Date lastUpdated` fields.\n<info added on 2025-09-24T21:55:06.937Z>\nAdicionar campos `status` (tipo `TaskStatus`) e `priority` (tipo `TaskPriority`) ao `Task.groovy`. Também declarar os campos `dateCreated` e `lastUpdated`, aproveitando o timestamp automático do GORM.\n</info added on 2025-09-24T21:55:06.937Z>\n<info added on 2025-09-24T22:03:31.417Z>\n[\n  1,\n  2,\n  3\n]\n</info added on 2025-09-24T22:03:31.417Z>",
            "testStrategy": "Write a simple unit test for `Task` to ensure `status` and `priority` fields are of the correct enum types and `dateCreated`/`lastUpdated` are recognized by GORM (e.g., by saving and retrieving an instance)."
          },
          {
            "id": 5,
            "title": "Implement Constraints and Default Values for Task Domain Class",
            "description": "Define `static constraints` block in `Task.groovy` for `title` (blank: false, maxSize: 255), `description` (nullable: true, maxSize: 1000). Set default values for `status` (PENDING) and `priority` (MEDIUM). [Updated: 9/24/2025]",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "In `grails-app/domain/todoapi/Task.groovy`, add a `static constraints` block with specified rules for `title` and `description`. Set `status = TaskStatus.PENDING` and `priority = TaskPriority.MEDIUM` as default values.\n<info added on 2025-09-24T21:55:20.485Z>\nDefinir o bloco `static constraints` no `grails-app/domain/todoapi/Task.groovy` para `title` (blank: false, maxSize: 255), `description` (nullable: true, maxSize: 1000). Definir valores padrão para `status` (TaskStatus.PENDING) e `priority` (TaskPriority.MEDIUM).\n</info added on 2025-09-24T21:55:20.485Z>\n<info added on 2025-09-24T22:06:54.165Z>\n[\n  4\n]\n</info added on 2025-09-24T22:06:54.165Z>",
            "testStrategy": "Write unit tests for `Task` to verify `title` constraints (blank, maxSize), `description` constraints (nullable, maxSize), and that `status` defaults to `PENDING` and `priority` defaults to `MEDIUM` upon instantiation."
          }
        ]
      },
      {
        "id": 3,
        "title": "Desenvolver TaskService para Lógica de Negócio",
        "description": "Criar um `TaskService` para encapsular toda a lógica de negócio relacionada às tarefas, incluindo operações CRUD e atualizações de status.",
        "status": "todo",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "Implementar os seguintes métodos em `grails-app/services/todoapi/TaskService.groovy`, seguindo as convenções do Grails e a interação com `grails-app/controllers/todoapi/TaskController.groovy` e `grails-app/domain/todoapi/Task.groovy`:\n*   `listAllTasks()`: Deve retornar uma `List<Task>` de todas as tarefas existentes.\n*   `getTaskById(Long id)`: Deve buscar e retornar uma `Task` pelo seu `id`. Retornar `null` se a tarefa não for encontrada.\n*   `createTask(Task task)`: Recebe uma instância de `Task` (já preenchida via data binding do Grails). Deve validar a `task` (usando `task.validate()`), salvá-la usando GORM (`task.save()`) e retornar `true` em caso de sucesso, `false` caso contrário. Deve-se considerar a restrição de unicidade do `title` definida em `Task.groovy`.\n*   `updateTask(Long id, Task task)`: Recebe o `id` da tarefa a ser atualizada e uma instância de `Task` (data-bound) contendo os novos valores. Deve encontrar a tarefa existente pelo `id`, atualizar suas propriedades (ex: `title`, `description`, `status`, `priority`), validar a tarefa atualizada, salvá-la e retornar `true` em caso de sucesso, `false` caso contrário. Lidar com a unicidade do `title` durante a atualização, garantindo que o título não seja duplicado por outra tarefa (exceto a própria tarefa que está sendo atualizada).\n*   `deleteTask(Long id)`: Deve encontrar a tarefa por `id`, excluí-la usando GORM (`task.delete()`) e retornar `true` em caso de sucesso, `false` caso contrário.\n*   `updateTaskStatus(Long id, TaskStatus newStatus)`: Recebe o `id` da tarefa e o novo `status` como um enum `TaskStatus` (conforme definido em `Task.groovy`). Deve encontrar a tarefa, atualizar sua propriedade `status`, validar, salvar e retornar `true` em caso de sucesso, `false` caso contrário.\n\nAssegurar validação adequada (verificando `task.hasErrors()` após `task.validate()`) e tratamento de erros (retornando `false` ou `null` conforme as expectativas do controller). Todos os métodos de serviço são implicitamente transacionais por convenção do Grails.",
        "testStrategy": "Escrever testes de unidade para os métodos de `TaskService`, mockando as interações da classe de domínio `Task` (ex: `Task.get()`, `task.save()`, `task.delete()`, `task.validate()`). Cobrir todas as operações CRUD e mudanças de status, incluindo cenários de sucesso, falha de validação (ex: `title` em branco, `title` duplicado), tarefa não encontrada e `TaskStatus` inválido (embora o controller já converta para enum, o serviço deve ser robusto).",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implementar TaskRestController (Endpoints CRUD)",
        "description": "Criar um controlador RESTful para tarefas, implementando os endpoints CRUD básicos para a API.",
        "status": "todo",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Create `grails-app/controllers/todoapi/TaskRestController.groovy`. Implement actions for `GET /api/tasks` (list all), `GET /api/tasks/:id` (get by ID), `POST /api/tasks` (create), `PUT /api/tasks/:id` (update), and `DELETE /api/tasks/:id` (delete). Ensure responses are in JSON format.",
        "testStrategy": "Write integration tests for `TaskRestController` to verify each CRUD endpoint returns correct HTTP status codes and JSON payloads. Use `grails test-app integration: TaskRestController`.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TaskRestController file and basic setup",
            "description": "Create `grails-app/controllers/todoapi/TaskRestController.groovy`. Add the `@RestController` annotation, set `static responseFormats = ['json']`, import `grails.converters.JSON`, and inject `TaskService` for dependency injection.",
            "status": "pending",
            "dependencies": [],
            "details": "This subtask establishes the foundational file and configuration for the REST controller, ensuring it's recognized as a REST endpoint and can handle JSON responses. The `TaskService` will be injected to delegate business logic.\n<info added on 2025-09-24T21:55:34.572Z>\ntitle: \"Criar arquivo TaskRestController e configuração básica\"\ndescription: \"Criar `grails-app/controllers/todoapi/TaskRestController.groovy`. Adicionar a anotação `@RestController`, definir `static responseFormats = ['json']`, importar `grails.converters.JSON`, e injetar `TaskService` para injeção de dependência.\"\n</info added on 2025-09-24T21:55:34.572Z>\n<info added on 2025-09-24T22:10:04.084Z>\ntitle: \"Criar arquivo TaskRestController e configuração básica\"\ndescription: \"Criar `grails-app/controllers/todoapi/TaskRestController.groovy`. Adicionar a anotação `@RestController`, definir `static responseFormats = ['json']`, importar `grails.converters.JSON`, e injetar `TaskService` para injeção de dependência.\"\n</info added on 2025-09-24T22:10:04.084Z>",
            "testStrategy": "Verify the `TaskRestController.groovy` file exists in the correct path and compiles without errors. Check that `TaskService` is correctly injected (e.g., by running `grails compile`)."
          },
          {
            "id": 2,
            "title": "Implement GET /api/tasks (list all) and GET /api/tasks/:id (get by ID) actions",
            "description": "Implement the `index()` action to handle `GET /api/tasks` for listing all tasks and the `show(Long id)` action for `GET /api/tasks/:id` to retrieve a single task by ID. Both actions should delegate to `TaskService` methods (e.g., `listAllTasks()` and `getTask(id)`) and render the results as JSON. The `show` action must return a 404 status if the task with the given ID is not found.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "These actions provide read-only access to task data. They will utilize the `TaskService` to fetch data from the domain layer and format it as JSON for API consumers.\n<info added on 2025-09-24T21:55:44.892Z>\nImplementar a ação `index()` para lidar com `GET /api/tasks` para listar todas as tarefas e a ação `show(Long id)` para `GET /api/tasks/:id` para recuperar uma única tarefa por ID. Ambas as ações devem delegar para métodos do `TaskService` (ex: `listAllTasks()` e `getTaskById(id)`) e renderizar os resultados como JSON. A ação `show` deve retornar status 404 se a tarefa com o ID fornecido não for encontrada.\n</info added on 2025-09-24T21:55:44.892Z>\n<info added on 2025-09-24T22:10:25.587Z>\nImplementar a ação `index()` para lidar com `GET /api/tasks` para listar todas as tarefas e a ação `show(Long id)` para `GET /api/tasks/:id` para recuperar uma única tarefa por ID. Ambas as ações devem delegar para métodos do `TaskService` (ex: `listAllTasks()` e `getTaskById(id)`) e renderizar os resultados como JSON. A ação `show` deve retornar status 404 se a tarefa com o ID fornecido não for encontrada.\n</info added on 2025-09-24T22:10:25.587Z>",
            "testStrategy": "Write integration tests for `GET /api/tasks` to verify it returns a 200 status code and a JSON array of tasks. Write integration tests for `GET /api/tasks/:id` to verify it returns a 200 status code and a single task JSON object for an existing ID, and a 404 status code for a non-existent ID."
          },
          {
            "id": 3,
            "title": "Implement POST /api/tasks (create new task) action",
            "description": "Implement the `save()` action to handle `POST /api/tasks` for creating a new task. It should parse the request JSON body, delegate to a `TaskService` method (e.g., `createTask(Map data)`) to create the task, and handle validation errors by returning a 400 status code with error details in JSON. On successful creation, return the created task with a 201 status code.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "This action allows clients to submit new task data. It's crucial to include robust validation and provide clear error messages as per Task 13's requirements.\n<info added on 2025-09-24T21:55:56.330Z>\nImplementar a ação `save()` para lidar com `POST /api/tasks` para criar uma nova tarefa. Deve analisar o corpo JSON da requisição, delegar para um método do `TaskService` (ex: `createTask(Map data)`) para criar a tarefa, e lidar com erros de validação retornando status 400 com detalhes do erro em JSON. Em caso de criação bem-sucedida, retornar a tarefa criada com status 201.\n</info added on 2025-09-24T21:55:56.330Z>\n<info added on 2025-09-24T22:10:32.851Z>\ntitle: Implementar POST /api/tasks (criar nova tarefa)\ndescription: Implementar a ação `save()` para lidar com `POST /api/tasks` para criar uma nova tarefa. Deve analisar o corpo JSON da requisição, delegar para um método do `TaskService` (ex: `createTask(Map data)`) para criar a tarefa, e lidar com erros de validação retornando status 400 com detalhes do erro em JSON. Em caso de criação bem-sucedida, retornar a tarefa criada com status 201.\n</info added on 2025-09-24T22:10:32.851Z>",
            "testStrategy": "Write integration tests for `POST /api/tasks` with valid task data (expect 201 status and the created task's JSON). Also, test with invalid task data (e.g., missing required fields, invalid status) to ensure a 400 status code and appropriate JSON error messages are returned."
          },
          {
            "id": 4,
            "title": "Implement PUT /api/tasks/:id (update existing task) action",
            "description": "Implement the `update(Long id)` action to handle `PUT /api/tasks/:id` for modifying an existing task. It should find the task by ID, parse the request JSON body, delegate to a `TaskService` method (e.g., `updateTask(Long id, Map data)`) to update the task, and handle validation errors (returning a 400 status code). Return a 404 status code if the task is not found. On successful update, return the updated task with a 200 status code.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "This action enables clients to modify existing task details. Similar to creation, validation and proper error handling are essential.\n<info added on 2025-09-24T21:56:11.386Z>\nImplementar a ação `update(Long id)` para lidar com `PUT /api/tasks/:id` para modificar uma tarefa existente. Deve encontrar a tarefa por ID, analisar o corpo JSON da requisição, delegar para um método do `TaskService` (ex: `updateTask(Long id, Map data)`) para atualizar a tarefa, e lidar com erros de validação (retornando status 400). Retornar status 404 se a tarefa não for encontrada. Em caso de atualização bem-sucedida, retornar a tarefa atualizada com status 200.\n</info added on 2025-09-24T21:56:11.386Z>\n<info added on 2025-09-24T22:10:52.183Z>\ntitle: Implementar PUT /api/tasks/:id (atualizar tarefa existente)\ndescription: Implementar a ação `update(Long id)` para lidar com `PUT /api/tasks/:id` para modificar uma tarefa existente. Deve encontrar a tarefa por ID, analisar o corpo JSON da requisição, delegar para um método do `TaskService` (ex: `updateTask(Long id, Map data)`) para atualizar a tarefa, e lidar com erros de validação (retornando status 400). Retornar status 404 se a tarefa não for encontrada. Em caso de atualização bem-sucedida, retornar a tarefa atualizada com status 200.\n</info added on 2025-09-24T22:10:52.183Z>",
            "testStrategy": "Write integration tests for `PUT /api/tasks/:id` with valid update data for an existing task (expect 200 status and the updated task's JSON). Test with invalid update data (expect 400 status and error JSON). Test with a non-existent task ID to ensure a 404 status code is returned."
          },
          {
            "id": 5,
            "title": "Implement DELETE /api/tasks/:id (delete task) action",
            "description": "Implement the `delete(Long id)` action to handle `DELETE /api/tasks/:id` for removing a task. It should delegate to a `TaskService` method (e.g., `deleteTask(Long id)`) to perform the deletion. Return a 204 (No Content) status code on successful deletion and a 404 status code if the task with the given ID is not found.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "This action provides the functionality to remove tasks from the system. It should confirm the task's existence before attempting deletion.\n<info added on 2025-09-24T21:56:13.814Z>\nTítulo: Implementar DELETE /api/tasks/:id (excluir tarefa)\nDescrição: Implementar a ação `delete(Long id)` para lidar com `DELETE /api/tasks/:id` para remover uma tarefa. Deve delegar para um método do `TaskService` (ex: `deleteTask(Long id)`) para realizar a exclusão. Retornar status 204 (No Content) em caso de exclusão bem-sucedida e status 404 se a tarefa com o ID fornecido não for encontrada.\n</info added on 2025-09-24T21:56:13.814Z>\n<info added on 2025-09-24T22:11:05.674Z>\nTítulo: Implementar DELETE /api/tasks/:id (excluir tarefa)\nDescrição: Implementar a ação `delete(Long id)` para lidar com `DELETE /api/tasks/:id` para remover uma tarefa. Deve delegar para um método do `TaskService` (ex: `deleteTask(Long id)`) para realizar a exclusão. Retornar status 204 (No Content) em caso de exclusão bem-sucedida e status 404 se a tarefa com o ID fornecido não for encontrada.\n</info added on 2025-09-24T22:11:05.674Z>",
            "testStrategy": "Write integration tests for `DELETE /api/tasks/:id` for an existing task (expect 204 status code and verify the task is no longer retrievable). Test with a non-existent task ID to ensure a 404 status code is returned."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implementar TaskRestController (Endpoint de Atualização de Status)",
        "description": "Adicionar o endpoint específico para atualizar o status de uma tarefa no `TaskRestController`.",
        "status": "todo",
        "dependencies": [
          4
        ],
        "priority": "high",
        "details": "Adicionar uma ação ao `grails-app/controllers/todoapi/TaskRestController.groovy` para `PATCH /api/tasks/:id/status`. Esta ação deve aceitar um novo status (PENDING/COMPLETED) no corpo da requisição (ex: `{\"status\": \"COMPLETED\"}`) e atualizar a tarefa de acordo, delegando a lógica para um novo método no `grails-app/services/todoapi/TaskService.groovy`. \n\n**No `TaskRestController.groovy`:**\n1.  Adicionar um método `updateStatus(Long id)`.\n2.  Configurar `static allowedMethods = [..., updateStatus: 'PATCH']`.\n3.  Obter o `id` da tarefa do path e o novo status (string) de `request.JSON.status`.\n4.  Chamar um novo método no `taskService` (ex: `taskService.updateTaskStatus(id, newStatusString)`).\n5.  Lidar com os seguintes cenários e respostas HTTP:\n    *   Tarefa não encontrada: `render status: NOT_FOUND, text: \"Task not found\"`.\n    *   Status inválido (não corresponde a `TaskStatus.PENDING` ou `TaskStatus.COMPLETED`): `render status: BAD_REQUEST, json: [error: \"Invalid status provided. Must be PENDING or COMPLETED.\"]`.\n    *   Sucesso: `render status: OK, json: updatedTask`.\n\n**No `grails-app/services/todoapi/TaskService.groovy`:**\n1.  Adicionar um método `updateTaskStatus(Long id, String newStatusString)`.\n2.  Buscar a tarefa pelo `id` usando `Task.get(id)`. Se não encontrada, retornar `null`.\n3.  Converter `newStatusString` para o enum `todoapi.TaskStatus` (ex: `TaskStatus.valueOf(newStatusString.toUpperCase())`). Lançar `IllegalArgumentException` se o status for inválido.\n4.  Atualizar o campo `task.status` com o novo valor do enum.\n5.  Persistir a tarefa atualizada usando `task.save(flush: true)`.\n6.  Retornar a tarefa atualizada.\n\n**No `grails-app/conf/UrlMappings.groovy`:**\n1.  Adicionar um mapeamento para o novo endpoint: `PATCH \"/api/tasks/$id/status\"(controller: \"taskRest\", action: \"updateStatus\")`.",
        "testStrategy": "Escrever testes de integração para o endpoint `PATCH /api/tasks/:id/status`, verificando a atualização do status e as respostas apropriadas (200 OK para sucesso, 404 NOT FOUND para tarefa inexistente, 400 BAD REQUEST para status inválido).",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Criar TaskController para Views Web",
        "description": "Configurar o controlador web principal para lidar com requisições relacionadas às páginas GSP para tarefas.",
        "status": "todo",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Create `grails-app/controllers/todoapi/TaskController.groovy`. Implement actions for `/tasks` (list), `/tasks/create` (show create form), `/tasks/:id` (show detail), `/tasks/:id/edit` (show edit form). These actions will render the corresponding GSP views.",
        "testStrategy": "Write unit tests for `TaskController` to ensure correct view rendering and model passing. Verify URL mappings in `UrlMappings.groovy`.",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Desenvolver GSP de Listagem de Tarefas (`/tasks`)",
        "description": "Criar a página GSP para exibir uma lista de todas as tarefas, incluindo informações básicas das tarefas.",
        "status": "todo",
        "dependencies": [
          6
        ],
        "priority": "high",
        "details": "Create `grails-app/views/task/list.gsp`. This page should display tasks in a table or card format, showing title, status, priority, and links to view/edit/delete. Use Bootstrap for styling.",
        "testStrategy": "Manually navigate to `/tasks` in the browser and verify tasks are displayed correctly. Check for basic styling and links.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `index` action in `TaskController`",
            "description": "Create or modify the `index` action in `grails-app/controllers/todoapi/TaskController.groovy` to fetch all tasks using `taskService.listAllTasks()` and pass them to the `list.gsp` view as a model attribute (e.g., `taskList`).",
            "status": "pending",
            "dependencies": [],
            "details": "Ensure the `TaskService` is correctly injected. The action should return `[taskList: taskService.listAllTasks()]`.\n<info added on 2025-09-24T21:56:52.456Z>\nTítulo: Implementar ação `index` no `TaskController`\nDescrição: Criar ou modificar a ação `index` em `grails-app/controllers/todoapi/TaskController.groovy` para buscar todas as tarefas usando `taskService.listAllTasks()` e passá-las para a view `list.gsp` como atributo do modelo (ex: `taskList`).\n</info added on 2025-09-24T21:56:52.456Z>\n<info added on 2025-09-24T22:11:50.238Z>\nTítulo: Implementar ação `index` no `TaskController`\nDescrição: Criar ou modificar a ação `index` em `grails-app/controllers/todoapi/TaskController.groovy` para buscar todas as tarefas usando `taskService.listAllTasks()` e passá-las para a view `list.gsp` como atributo do modelo (ex: `taskList`).\n</info added on 2025-09-24T22:11:50.238Z>",
            "testStrategy": "Manually navigate to `/tasks` and verify that the `list.gsp` view is rendered (even if empty initially) and no errors occur."
          },
          {
            "id": 2,
            "title": "Create `list.gsp` with basic Bootstrap layout",
            "description": "Create the file `grails-app/views/task/list.gsp`. Include a basic HTML structure with a page title and a container (`div` with Bootstrap classes like `container` or `row`/`col`) to hold the task list. Ensure it uses the main layout.",
            "status": "pending",
            "dependencies": [],
            "details": "Use `<g:layoutTitle>` for the page title. The file should implicitly use `grails-app/views/layouts/main.gsp`.\n<info added on 2025-09-24T21:56:55.181Z>\nCriar `list.gsp` com layout básico do Bootstrap\" - \"Criar o arquivo `grails-app/views/task/list.gsp`. Incluir uma estrutura HTML básica com um título da página e um container (`div` com classes do Bootstrap como `container` ou `row`/`col`) para conter a lista de tarefas. Garantir que use o layout principal.\n</info added on 2025-09-24T21:56:55.181Z>\n<info added on 2025-09-24T22:11:56.982Z>\nCriar `list.gsp` com layout básico do Bootstrap\" - \"Criar o arquivo `grails-app/views/task/list.gsp`. Incluir uma estrutura HTML básica com um título da página e um container (`div` com classes do Bootstrap como `container` ou `row`/`col`) para conter a lista de tarefas. Garantir que use o layout principal.\n</info added on 2025-09-24T22:11:56.982Z>",
            "testStrategy": "Manually navigate to `/tasks` and verify that the page loads with the correct title and basic layout, without displaying any tasks yet."
          },
          {
            "id": 3,
            "title": "Display tasks in a Bootstrap table",
            "description": "In `grails-app/views/task/list.gsp`, iterate over the `taskList` model attribute. For each task, display its `title`, `status`, and `priority` within a Bootstrap-styled HTML table.",
            "status": "pending",
            "dependencies": [
              1,
              2
            ],
            "details": "Use `<g:each in=\"${taskList}\" var=\"task\">` to loop through tasks. Apply Bootstrap table classes like `table`, `table-striped`, `table-hover`.\n<info added on 2025-09-24T21:57:14.276Z>\nEm `grails-app/views/task/list.gsp`, iterar sobre o atributo do modelo `taskList` usando `<g:each in=\"${taskList}\" var=\"task\">`. Para cada tarefa, exibir seu `title`, `status` e `priority` dentro de uma tabela HTML estilizada com Bootstrap, aplicando as classes `table`, `table-striped` e `table-hover`.\n</info added on 2025-09-24T21:57:14.276Z>\n<info added on 2025-09-24T22:13:00.082Z>\nEm `grails-app/views/task/list.gsp`, implementar uma tabela do Bootstrap (`<table class='table table-striped table-hover'>`) para exibir as tarefas. Iterar sobre o atributo do modelo `taskList` usando `<g:each in=\"${taskList}\" var=\"task\">`. Para cada tarefa, incluir colunas para: Título (`task.title`), Status (`task.status`), Prioridade (`task.priority`), Data de Criação (`task.dateCreated`), e Ações (links para Visualizar, Editar e Excluir). Garantir que a tabela seja responsiva, utilizando as classes Bootstrap apropriadas (ex: `table-responsive`).\n</info added on 2025-09-24T22:13:00.082Z>",
            "testStrategy": "Manually navigate to `/tasks` after creating some tasks (e.g., via console or another task). Verify that tasks are displayed in a table with the correct title, status, and priority."
          },
          {
            "id": 4,
            "title": "Add View, Edit, and Delete action links",
            "description": "For each task displayed in the table in `grails-app/views/task/list.gsp`, add columns for 'Actions'. Within these columns, include `g:link` tags for 'View', 'Edit', and 'Delete' actions, passing the `task.id` as a parameter.",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "The links should point to `controller: 'task', action: 'show', id: task.id`, `controller: 'task', action: 'edit', id: task.id`, and `controller: 'task', action: 'delete', id: task.id` respectively. Use appropriate Bootstrap button classes (e.g., `btn btn-info`, `btn btn-warning`, `btn btn-danger`).\n<info added on 2025-09-24T21:57:31.216Z>\nTítulo: Adicionar links de ação Visualizar, Editar e Excluir\nDescrição: Para cada tarefa exibida na tabela em `grails-app/views/task/list.gsp`, adicionar colunas para 'Ações'. Dentro dessas colunas, incluir tags `g:link` para ações 'Visualizar', 'Editar' e 'Excluir', passando o `task.id` como parâmetro.\n</info added on 2025-09-24T21:57:31.216Z>\n<info added on 2025-09-24T22:13:10.712Z>\n<info added on 2024-05-20T10:00:00Z>\nTítulo: Adicionar links de ação Visualizar, Editar e Excluir\nDescrição: Adicionar uma coluna de Ações na tabela de tarefas em `grails-app/views/task/list.gsp`. Incluir tags `g:link` para as ações 'Visualizar', 'Editar' e 'Excluir', passando o `task.id` como parâmetro. Os links devem apontar para `controller: 'task', action: 'show', id: task.id` (Visualizar), `controller: 'task', action: 'edit', id: task.id` (Editar) e `controller: 'task', action: 'delete', id: task.id` (Excluir). Utilizar ícones do Bootstrap (ex: `glyphicon`) e estilizar os links como botões pequenos (`btn btn-sm`) com classes apropriadas (e.g., `btn btn-info`, `btn btn-warning`, `btn btn-danger`). Implementar confirmação de exclusão com JavaScript para a ação 'Excluir'.\n</info added on 2024-05-20T10:00:00Z>\n</info added on 2025-09-24T22:13:10.712Z>",
            "testStrategy": "Manually navigate to `/tasks`. Verify that each task row has 'View', 'Edit', and 'Delete' links. Click on them to ensure they generate the correct URLs (even if the target pages are not yet implemented)."
          },
          {
            "id": 5,
            "title": "Implement empty state message and final styling adjustments",
            "description": "In `grails-app/views/task/list.gsp`, add conditional logic to display a user-friendly message (e.g., 'No tasks found.') if the `taskList` is empty. Make any final styling adjustments using Bootstrap to ensure a clean and responsive layout.",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Use `<g:if test=\"${taskList.empty}\">` and `<g:else>` blocks. Consider using Bootstrap alerts or cards for the empty state message. Ensure the overall page layout is consistent with other parts of the application.\n<info added on 2025-09-24T21:57:42.189Z>\nIn `grails-app/views/task/list.gsp`, place the existing task display (likely a Bootstrap `<table>` or card structure) inside a `<g:if test=\"${!taskList.empty}\">` block. For the empty state, within the corresponding `<g:else>` block, use a Bootstrap alert, for example, `<div class=\"alert alert-info\" role=\"alert\">Nenhuma tarefa encontrada.</div>`. This approach ensures consistency with the project's use of Bootstrap for UI elements and provides a clear user experience.\n</info added on 2025-09-24T21:57:42.189Z>\n<info added on 2025-09-24T22:13:27.956Z>\nAtualize a mensagem do estado vazio em `grails-app/views/task/list.gsp` para: `<div class=\"alert alert-info\" role=\"alert\">Nenhuma tarefa encontrada. Clique em \"Nova Tarefa\" para começar.</div>`. Adicione um botão 'Nova Tarefa' que redirecione para `/tasks/create`, utilizando `<g:link controller=\"task\" action=\"create\" class=\"btn btn-primary mt-3\">Nova Tarefa</g:link>`. Finalmente, aplique ajustes de estilo finais usando classes utilitárias do Bootstrap (ex: `mt-3`, `mb-4`, `p-3`, `container`, `row`, `col`) para melhorar a aparência geral da página, garantindo espaçamento, cores e responsividade consistentes com o `grails-app/views/layouts/main.gsp`.\n</info added on 2025-09-24T22:13:27.956Z>",
            "testStrategy": "Manually navigate to `/tasks` when no tasks exist in the database. Verify the empty state message is displayed. Create a task and verify the list appears correctly, and the empty state message is hidden. Check responsiveness on different screen sizes."
          }
        ]
      },
      {
        "id": 8,
        "title": "Desenvolver GSP de Criar/Editar Tarefa (`/tasks/create`, `/tasks/:id/edit`)",
        "description": "Criar uma única página GSP com um formulário para criar novas tarefas e editar tarefas existentes.",
        "status": "todo",
        "dependencies": [
          6
        ],
        "priority": "high",
        "details": "Crie o arquivo `grails-app/views/task/createEdit.gsp`. Este GSP será utilizado tanto para a criação quanto para a edição de tarefas. O formulário deve incluir os seguintes campos, baseados na classe de domínio `grails-app/domain/todoapi/Task.groovy`:\n\n1.  **Título (`title`):** Campo de texto.\n2.  **Descrição (`description`):** Área de texto.\n3.  **Status (`status`):** Dropdown com as opções do enum `src/groovy/todoapi/TaskStatus.groovy` (PENDING, COMPLETED).\n4.  **Prioridade (`priority`):** Dropdown com as opções do enum `src/groovy/todoapi/TaskPriority.groovy` (LOW, MEDIUM, HIGH).\n\n**Implementação:**\n*   Utilize as tags de formulário do Grails (ex: `g:form`, `g:textField`, `g:textArea`, `g:select`) para vincular os campos à instância de `Task`.\n*   Aplique classes do Bootstrap 4 (confirmado em `build.gradle` e `grails-app/views/layouts/main.gsp`) para layout e estilização (ex: `form-group`, `form-control`, `btn btn-primary`).\n*   **Lógica de Edição/Criação:**\n    *   O GSP receberá uma `taskInstance` do `TaskController.groovy`.\n    *   Se `taskInstance.id` for `null`, é uma nova tarefa (criação).\n    *   Se `taskInstance.id` existir, é uma tarefa existente (edição), e os campos devem ser pré-preenchidos automaticamente pelas tags do Grails.\n    *   O atributo `action` do `g:form` deve ser dinâmico, apontando para `save` para novas tarefas e `update` para tarefas existentes.\n*   **Integração com o Controller:**\n    *   Modifique as ações `create()` e `edit()` em `grails-app/controllers/todoapi/TaskController.groovy` para renderizar `createEdit.gsp`.\n        *   `create()`: `render(view: 'createEdit', model: [taskInstance: new Task()])`\n        *   `edit(Task taskInstance)`: `render(view: 'createEdit', model: [taskInstance: taskInstance])`\n    *   As ações `save()` e `update()` do controller continuarão a processar as submissões do formulário, validando e persistindo os dados.\n\n**Exemplo de estrutura para um campo de texto e um dropdown:**\n```gsp\n<g:form resource=\"task\" action=\"${taskInstance?.id ? 'update' : 'save'}\" ${taskInstance?.id ? 'method=\"PUT\"' : ''}>\n    <g:hiddenField name=\"id\" value=\"${taskInstance?.id}\" />\n    <div class=\"form-group\">\n        <label for=\"title\">Título</label>\n        <g:textField name=\"title\" value=\"${taskInstance?.title}\" class=\"form-control ${hasErrors(bean: taskInstance, field: 'title', 'is-invalid')}\" />\n        <g:hasErrors bean=\"taskInstance\" field=\"title\">\n            <div class=\"invalid-feedback\"><g:message error=\"${error}\"/></div>\n        </g:hasErrors>\n    </div>\n\n    <div class=\"form-group\">\n        <label for=\"status\">Status</label>\n        <g:select name=\"status\" from=\"${todoapi.TaskStatus.values()}\" keys=\"${todoapi.TaskStatus.values()}\" value=\"${taskInstance?.status}\" class=\"form-control ${hasErrors(bean: taskInstance, field: 'status', 'is-invalid')}\" />\n        <g:hasErrors bean=\"taskInstance\" field=\"status\">\n            <div class=\"invalid-feedback\"><g:message error=\"${error}\"/></div>\n        </g:hasErrors>\n    </div>\n\n    <button type=\"submit\" class=\"btn btn-primary\">Salvar Tarefa</button>\n</g:form>\n```",
        "testStrategy": "Manualmente, acesse `/tasks/create` para criar uma nova tarefa e `/tasks/:id/edit` para editar uma tarefa existente. Verifique se os campos são pré-preenchidos corretamente na edição, se a validação funciona e se os dados são persistidos e exibidos corretamente após a submissão do formulário. Teste ambos os fluxos (criação e edição) e a exibição de mensagens de erro de validação.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Desenvolver GSP de Visualização de Tarefa (`/tasks/:id`)",
        "description": "Criar uma página GSP para exibir as informações detalhadas de uma única tarefa.",
        "status": "todo",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "details": "Crie `grails-app/views/task/show.gsp`. Este GSP deve utilizar o layout `grails-app/views/layouts/main.gsp`.\n\nO `todoapi.TaskController` precisará de uma ação `show` que buscará o objeto `Task` usando `taskService.getTaskById(id)` (conforme definido na Task 3) e o passará para a view. \n\nDentro de `show.gsp`, exiba os seguintes campos da tarefa:\n*   `task.id`\n*   `task.title`\n*   `task.description`\n*   `task.status` (ex: `task.status.name()`, utilizando os enums de `TaskStatus` da Task 2)\n*   `task.priority` (ex: `task.priority.name()`, utilizando os enums de `TaskPriority` da Task 2)\n*   `task.dateCreated`\n*   `task.lastUpdated`\n\nUtilize classes do Bootstrap (como `card`, `card-header`, `card-body`, `list-group`, `list-group-item`) para uma apresentação amigável. \n\nInclua links de ação:\n*   **Editar:** Um link para a ação `edit` do `TaskController` para a tarefa atual: `<g:link action=\"edit\" id=\"${task.id}\" class=\"btn btn-primary\">Editar</g:link>`.\n*   **Excluir:** Um link para a ação `delete` do `TaskController` para a tarefa atual, com um prompt de confirmação: `<g:link action=\"delete\" id=\"${task.id}\" class=\"btn btn-danger\" onclick=\"return confirm('Tem certeza que deseja excluir esta tarefa?');\">Excluir</g:link>`.\n*   **Voltar:** Um link para a ação `list` do `TaskController` (conforme definido na Task 7): `<g:link action=\"list\" class=\"btn btn-secondary\">Voltar para a Lista</g:link>`.",
        "testStrategy": "Navegue manualmente para a página de detalhes de uma tarefa (ex: `/tasks/1`) e verifique se todas as informações são exibidas corretamente. Verifique a formatação adequada e a funcionalidade dos links 'Editar', 'Excluir' e 'Voltar para a Lista'.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implementar Busca, Filtro, Ordenação e Paginação para Lista Web",
        "description": "Aprimorar a GSP de lista de tarefas e o controlador para suportar busca por título, filtro por status/prioridade, ordenação por vários campos e paginação.",
        "status": "todo",
        "dependencies": [
          7
        ],
        "priority": "high",
        "details": "**No `grails-app/controllers/todoapi/TaskController.groovy`:**\n1.  Modificar a ação `list` para aceitar parâmetros de requisição para busca (`params.q`), filtros (`params.status`, `params.priority`), ordenação (`params.sort`, `params.order`) e paginação (`params.max`, `params.offset`).\n2.  Delegar a lógica de busca, filtro, ordenação e paginação para um novo método no `grails-app/services/todoapi/TaskService.groovy`, por exemplo, `taskService.listTasks(params)`. Este método deve utilizar GORM (finders dinâmicos ou Criteria API) para construir a consulta.\n3.  Passar os resultados da consulta (lista de tarefas e contagem total) para a view `list.gsp`.\n\n**No `grails-app/services/todoapi/TaskService.groovy`:**\n1.  Criar ou atualizar um método (ex: `listTasks(Map params)`) que construa e execute a consulta de tarefas com base nos parâmetros fornecidos, aplicando busca por `title` (usando `ILIKE` ou `like`), filtros por `status` (usando `TaskStatus` enum) e `priority` (usando `TaskPriority` enum), ordenação e paginação.\n\n**No `grails-app/views/task/list.gsp`:**\n1.  Adicionar um campo de entrada para busca por título (ex: `<g:textField name=\"q\" value=\"${params.q}\" />`).\n2.  Incluir dropdowns para filtrar por status e prioridade, utilizando os enums `TaskStatus` e `TaskPriority` (ex: `<g:select name=\"status\" from=\"${TaskStatus.values()}\" value=\"${params.status?.toString()}\" noSelection=\"['': 'Todos os Status']\" optionKey=\"name\" />`).\n3.  Modificar os cabeçalhos da tabela para serem clicáveis e permitirem a ordenação, utilizando a tag `<g:sortableColumn>` para campos como `title`, `priority` e `dateCreated`.\n4.  Adicionar controles de paginação na parte inferior da lista, utilizando a tag `<g:paginate total=\"${taskCount}\" />`.",
        "testStrategy": "Manualmente testar todas as combinações de busca, filtro, ordenação e paginação no navegador. Verificar resultados corretos e comportamento da UI.",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implementar Ações em Lote para Lista Web",
        "description": "Adicionar funcionalidade à GSP de lista de tarefas para permitir que os usuários selecionem múltiplas tarefas e realizem ações em lote, como marcá-las como concluídas.",
        "status": "todo",
        "dependencies": [
          10,
          5
        ],
        "priority": "medium",
        "details": "Modificar `grails-app/views/task/list.gsp` para incluir checkboxes ao lado de cada tarefa e um botão 'Marcar como Concluído'. Implementar uma função JavaScript (utilizando jQuery) para coletar os IDs das tarefas selecionadas e enviá-los para uma nova ação em `grails-app/controllers/todoapi/TaskController.groovy` (ex: `batchUpdateStatus`). Esta ação delegará a lógica para um novo método em `grails-app/services/todoapi/TaskService.groovy` (ex: `updateTasksStatusBatch`), que por sua vez pode reutilizar a lógica de atualização de status de tarefa individual já existente ou a ser criada (conforme Task 5).\n\n**Modificações em `grails-app/views/task/list.gsp`:**\n1.  Adicionar uma coluna de checkbox na tabela de tarefas. Para cada tarefa, incluir um `<input type=\"checkbox\" name=\"selectedTaskIds\" value=\"${task.id}\" class=\"task-checkbox\">`.\n2.  Adicionar um botão 'Marcar como Concluído' (ex: `<button id=\"markCompletedBtn\" class=\"btn btn-primary\">Marcar como Concluído</button>`).\n3.  Incluir um bloco `<script>` (preferencialmente no final do arquivo ou em um arquivo JS separado como `web-app/js/task-batch-actions.js`) com a lógica JavaScript.\n\n**Lógica JavaScript (jQuery) em `list.gsp`:**\n```javascript\n$(document).ready(function() {\n    $('#markCompletedBtn').on('click', function() {\n        const selectedTaskIds = [];\n        $('.task-checkbox:checked').each(function() {\n            selectedTaskIds.push($(this).val());\n        });\n\n        if (selectedTaskIds.length === 0) {\n            alert('Selecione pelo menos uma tarefa para realizar a ação.');\n            return;\n        }\n\n        if (confirm('Tem certeza que deseja marcar as tarefas selecionadas como CONCLUÍDAS?')) {\n            $.ajax({\n                url: '${g.createLink(controller: 'task', action: 'batchUpdateStatus')}',\n                type: 'POST',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                    taskIds: selectedTaskIds,\n                    newStatus: 'COMPLETED' // Usar o valor do enum TaskStatus\n                }),\n                success: function(response) {\n                    if (response.success) {\n                        alert('Tarefas atualizadas com sucesso!');\n                        location.reload(); // Recarregar a página para refletir as mudanças\n                    } else {\n                        alert('Erro ao atualizar tarefas: ' + (response.message || 'Erro desconhecido.'));\n                    }\n                },\n                error: function(xhr, status, error) {\n                    alert('Erro na requisição: ' + xhr.responseText);\n                }\n            });\n        }\n    });\n});\n```\n\n**Modificações em `grails-app/controllers/todoapi/TaskController.groovy`:**\n1.  Adicionar uma nova ação `batchUpdateStatus`:\n    ```groovy\n    package todoapi\n\n    import grails.converters.JSON\n    import todoapi.TaskStatus\n\n    class TaskController {\n        TaskService taskService\n\n        // ... outras ações ...\n\n        def batchUpdateStatus() {\n            if (request.method == 'POST') {\n                def json = request.JSON\n                List<Long> taskIds = json.taskIds as List<Long>\n                String newStatusString = json.newStatus\n\n                if (!taskIds || taskIds.isEmpty() || !newStatusString) {\n                    render status: 400, text: [success: false, message: 'IDs das tarefas ou novo status são obrigatórios'] as JSON\n                    return\n                }\n\n                try {\n                    TaskStatus newStatus = TaskStatus.valueOf(newStatusString)\n                    taskService.updateTasksStatusBatch(taskIds, newStatus)\n                    render status: 200, text: [success: true, message: 'Tarefas atualizadas com sucesso'] as JSON\n                } catch (IllegalArgumentException e) {\n                    render status: 400, text: [success: false, message: 'Status inválido fornecido'] as JSON\n                } catch (Exception e) {\n                    log.error(\"Erro ao atualizar tarefas em lote: ${e.message}\", e)\n                    render status: 500, text: [success: false, message: 'Erro interno do servidor ao atualizar tarefas'] as JSON\n                }\n            } else {\n                render status: 405, text: [success: false, message: 'Método não permitido'] as JSON\n            }\n        }\n    }\n    ```\n\n**Modificações em `grails-app/services/todoapi/TaskService.groovy`:**\n1.  Adicionar um novo método `updateTasksStatusBatch` que pode reutilizar o método de atualização de status individual (conforme Task 5):\n    ```groovy\n    package todoapi\n\n    import grails.gorm.transactions.Transactional\n\n    @Transactional\n    class TaskService {\n\n        // ... outros métodos ...\n\n        /**\n         * Atualiza o status de múltiplas tarefas.\n         * Reutiliza o método de atualização de status de tarefa individual.\n         * @param taskIds Lista de IDs das tarefas a serem atualizadas.\n         * @param newStatus O novo status a ser aplicado.\n         * @return true se todas as tarefas foram processadas, false se houve algum erro.\n         */\n        boolean updateTasksStatusBatch(List<Long> taskIds, TaskStatus newStatus) {\n            boolean allSuccessful = true\n            taskIds.each { id ->\n                try {\n                    // Assumindo que updateTaskStatus(id, newStatus) existe ou será criado pela Task 5\n                    // e lida com a persistência e validação de uma única tarefa.\n                    // Se não existir, a lógica de carregar e salvar a tarefa deve ser implementada aqui.\n                    Task task = Task.get(id)\n                    if (task) {\n                        task.status = newStatus\n                        if (!task.save(flush: true, failOnError: false)) {\n                            log.error(\"Falha ao salvar tarefa ${id}: ${task.errors}\")\n                            allSuccessful = false\n                        }\n                    } else {\n                        log.warn(\"Tarefa com ID ${id} não encontrada para atualização em lote.\")\n                        allSuccessful = false\n                    }\n                } catch (Exception e) {\n                    log.error(\"Erro ao atualizar tarefa ${id} em lote: ${e.message}\", e)\n                    allSuccessful = false\n                }\n            }\n            return allSuccessful\n        }\n\n        // Método updateTaskStatus(Long id, TaskStatus newStatus) será implementado na Task 5\n        // ou a lógica acima pode ser refatorada para chamá-lo se já existir.\n    }\n    ```",
        "testStrategy": "Testar manualmente selecionando múltiplas tarefas e aplicando a ação 'Marcar como Concluído'. Verificar se o status das tarefas selecionadas muda corretamente na lista e no banco de dados. Testar casos de borda como nenhuma tarefa selecionada, todas as tarefas selecionadas, e erros de requisição.",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Desenvolver GSP de Dashboard (`/`)",
        "description": "Criar uma página de dashboard que forneça uma visão geral das estatísticas das tarefas.",
        "status": "todo",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Para desenvolver o dashboard, siga os passos abaixo, alinhando-se com a arquitetura Grails existente e o uso de Bootstrap:\n\n1.  **Configurar Mapeamento de URL:**\n    *   Verifique ou adicione em `grails-app/controllers/UrlMappings.groovy` um mapeamento para a raiz (`/`) que aponte para um controlador e ação específicos, por exemplo:\n        ```groovy\n        \"/\"(controller: \"home\", action: \"index\")\n        ```\n\n2.  **Criar o Controlador do Dashboard:**\n    *   Crie o arquivo `grails-app/controllers/HomeController.groovy` (ou `ApplicationController.groovy` se preferir um controlador mais genérico para a raiz).\n    *   Neste controlador, injete `TaskService` e implemente a ação `index` para coletar as estatísticas:\n        ```groovy\n        package todoapi\n\n        class HomeController {\n            def taskService // Injeção do TaskService\n\n            def index() {\n                def totalTasks = taskService.countTotalTasks()\n                def pendingTasks = taskService.countTasksByStatus(TaskStatus.PENDING)\n                def completedTasks = taskService.countTasksByStatus(TaskStatus.COMPLETED)\n                def priorityCounts = taskService.getTaskPriorityCounts()\n\n                [totalTasks: totalTasks, pendingTasks: pendingTasks, completedTasks: completedTasks, priorityCounts: priorityCounts]\n            }\n        }\n        ```\n\n3.  **Adicionar Métodos de Estatísticas ao `TaskService`:**\n    *   No arquivo `grails-app/services/todoapi/TaskService.groovy`, adicione os seguintes métodos para recuperar as estatísticas:\n        ```groovy\n        package todoapi\n\n        import grails.gorm.transactions.Transactional\n\n        @Transactional\n        class TaskService {\n\n            // ... métodos existentes ...\n\n            long countTotalTasks() {\n                Task.count()\n            }\n\n            long countTasksByStatus(TaskStatus status) {\n                Task.countByStatus(status)\n            }\n\n            Map<TaskPriority, Long> getTaskPriorityCounts() {\n                def counts = [:]\n                TaskPriority.values().each { priority ->\n                    counts[priority] = Task.countByPriority(priority)\n                }\n                counts\n            }\n        }\n        ```\n\n4.  **Criar a View GSP do Dashboard:**\n    *   Crie o arquivo `grails-app/views/home/index.gsp` (assumindo `HomeController`).\n    *   Utilize componentes Bootstrap (como cards ou panels) para exibir as estatísticas passadas pelo modelo (ex: `totalTasks`, `pendingTasks`, `completedTasks`, `priorityCounts`).\n    *   Exemplo de estrutura básica no GSP:\n        ```html\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <meta name=\"layout\" content=\"main\"/>\n            <title>Dashboard de Tarefas</title>\n        </head>\n        <body>\n            <div class=\"container\">\n                <h1>Dashboard de Tarefas</h1>\n                <div class=\"row mt-4\">\n                    <div class=\"col-md-3\">\n                        <div class=\"card text-white bg-primary mb-3\">\n                            <div class=\"card-header\">Total de Tarefas</div>\n                            <div class=\"card-body\">\n                                <h5 class=\"card-title\">${totalTasks}</h5>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"col-md-3\">\n                        <div class=\"card text-white bg-warning mb-3\">\n                            <div class=\"card-header\">Tarefas Pendentes</div>\n                            <div class=\"card-body\">\n                                <h5 class=\"card-title\">${pendingTasks}</h5>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"col-md-3\">\n                        <div class=\"card text-white bg-success mb-3\">\n                            <div class=\"card-header\">Tarefas Concluídas</div>\n                            <div class=\"card-body\">\n                                <h5 class=\"card-title\">${completedTasks}</h5>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"row mt-4\">\n                    <div class=\"col-md-12\">\n                        <h3>Tarefas por Prioridade</h3>\n                        <g:each in=\"${priorityCounts}\" var=\"entry\">\n                            <span class=\"badge badge-info\">${entry.key}: ${entry.value}</span>\n                        </g:each>\n                    </div>\n                </div>\n            </div>\n        </body>\n        </html>\n        ```\n\n    *   Certifique-se de que o layout `main.gsp` (em `grails-app/views/layouts/main.gsp`) inclua os arquivos CSS e JS do Bootstrap para que o estilo seja aplicado corretamente.",
        "testStrategy": "1.  Inicie a aplicação Grails.\n2.  Navegue manualmente para a URL raiz (`/`) no navegador.\n3.  Verifique se a página do dashboard é carregada corretamente.\n4.  Confirme se as estatísticas (Total de Tarefas, Tarefas Pendentes, Tarefas Concluídas e Tarefas por Prioridade) são exibidas e correspondem aos dados atuais no banco de dados.\n5.  Crie, edite e exclua algumas tarefas (via API ou outras interfaces, se disponíveis) e, em seguida, atualize a página do dashboard para verificar se as estatísticas são atualizadas dinamicamente e refletem as mudanças.",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implementar Validação Robusta de Dados e Tratamento de Erros",
        "description": "Garantir que todas as entradas de dados sejam validadas adequadamente e que o sistema forneça mensagens de erro significativas para interfaces de API e web.",
        "status": "todo",
        "dependencies": [
          4,
          8
        ],
        "priority": "high",
        "details": "Aproveitar a validação embutida do Grails nas classes de domínio e controladores. Implementar lógica de validação personalizada em `grails-app/services/todoapi/TaskService.groovy` se necessário. \n\n**Para a API (TaskRestController):**\n1.  Em `grails-app/controllers/todoapi/TaskRestController.groovy`, para as ações `save` (POST /api/tasks) e `update` (PUT /api/tasks/:id), verificar `task.validate()`. Se a validação falhar, retornar `HTTP 400 Bad Request` com um corpo JSON contendo os erros de validação (ex: `render status: 400, json: [message: 'Validation failed', errors: task.errors.allErrors.collect { message(error: it) }]`).\n2.  Para as ações que buscam ou modificam uma tarefa específica (`show`, `update`, `delete`, `updateStatus`), se a tarefa não for encontrada, retornar `HTTP 404 Not Found` com um corpo JSON (ex: `render status: 404, json: [message: 'Task not found']`).\n3.  A ação `updateStatus` (PATCH /api/tasks/:id/status) deve validar o novo status recebido, retornando `HTTP 400 Bad Request` se o valor for inválido.\n\n**Para a Interface Web (GSP):**\n1.  Em `grails-app/controllers/todoapi/TaskController.groovy`, nas ações `save` e `update`, se `task.validate()` falhar, renderizar novamente a view de formulário (`create.gsp` ou `edit.gsp`) passando a instância da tarefa com os erros (ex: `render view: 'create', model: [task: task]`).\n2.  Nas views GSP de criação e edição de tarefas (`grails-app/views/task/create.gsp`, `grails-app/views/task/edit.gsp`), utilizar as tags Grails `<g:hasErrors>`, `<g:renderErrors>` e `<g:fieldError>` para exibir mensagens de erro de validação ao lado dos campos do formulário.\n\n**Validação de Domínio:**\n1.  Garantir que `grails-app/domain/todoapi/Task.groovy` contenha as `static constraints` apropriadas para todos os campos (ex: `title blank: false, maxSize: 255`, `description nullable: true, maxSize: 1000`).\n\n**Validação de Serviço:**\n1.  Em `grails-app/services/todoapi/TaskService.groovy`, os métodos que persistem ou atualizam tarefas (ex: `save`, `updateTask`) devem invocar `task.validate()` antes de chamar `task.save()`. Se a validação falhar, o método deve retornar a tarefa com os erros ou um indicador de falha, permitindo que o controlador lide com a resposta apropriada.",
        "testStrategy": "Submeter dados inválidos através da API (usando cURL ou Postman) e dos formulários web. Verificar se as respostas de erro corretas e as mensagens são exibidas:\n-   **API:** Testar criação/atualização de tarefa com título vazio, descrição muito longa, status/prioridade inválidos. Verificar `HTTP 400` e o JSON de erros. Testar acesso/modificação de tarefa inexistente. Verificar `HTTP 404`.\n-   **Web:** Testar criação/edição de tarefa com dados inválidos. Verificar se as mensagens de erro aparecem nos campos do formulário na GSP.",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Escrever Testes Abrangentes Unitários e de Integração com Spock e TestContainers",
        "description": "Desenvolver uma suíte robusta de testes unitários e de integração para o `TaskService`, `TaskRestController` e `TaskController` usando Spock Framework para testes unitários e TestContainers para testes de integração, garantindo qualidade e funcionalidade do código.",
        "status": "todo",
        "dependencies": [
          17
        ],
        "priority": "high",
        "details": "This task involves writing comprehensive unit and integration tests for `TaskService`, `TaskController`, and `TaskRestController` using Spock Framework and TestContainers. The necessary test environment setup, including dependency configuration, `DataSource` setup for TestContainers, and the creation of base specification classes (`BaseIntegrationSpec`), is handled by **Task 17: Configurar Ambiente de Testes com Spock e TestContainers**. This task focuses solely on implementing the test logic to achieve high code coverage for the core application components.\n\n**1. Unit Test Structure (for `TaskService` and `TaskController`):**\n   Unit tests for `TaskService` (`grails-app/services/todoapi/TaskService.groovy`) and `TaskController` (`grails-app/controllers/todoapi/TaskController.groovy`) should extend `grails.test.mixin.TestFor` and implement `spock.lang.Specification`. Create new test files in `test/unit/todoapi/` (e.g., `TaskServiceSpec.groovy`, `TaskControllerSpec.groovy`).\n     *Example `TaskServiceSpec.groovy` structure:*\n     ```groovy\n     package todoapi\n\n     import grails.test.mixin.TestFor\n     import spock.lang.Specification\n\n     @TestFor(TaskService)\n     class TaskServiceSpec extends Specification {\n\n         def setup() {\n             // Setup for each feature method, e.g., mock dependencies\n         }\n\n         def cleanup() {\n             // Cleanup for each feature method\n         }\n\n         void \"test listAllTasks returns all tasks\"() {\n             given:\n             // Mock Task.list() or other domain class interactions\n             Task.metaClass.static.list = { -> [new Task(title: 'Test 1'), new Task(title: 'Test 2')] }\n\n             when:\n             def tasks = service.listAllTasks()\n\n             then:\n             tasks.size() == 2\n             tasks[0].title == 'Test 1'\n         }\n\n         // ... other unit tests for TaskService methods (create, get, update, delete, updateStatus)\n     }\n     ```\n\n**2. Integration Test Structure (for `TaskRestController`):**\n   Integration tests for `TaskRestController` (`grails-app/controllers/todoapi/TaskRestController.groovy`) should extend the `BaseIntegrationSpec` (provided by Task 17) and be placed in `test/integration/todoapi/` (e.g., `TaskRestControllerIntegrationSpec.groovy`). These tests will interact with the TestContainers-managed MySQL database.\n     *Example `TaskRestControllerIntegrationSpec.groovy` extending `BaseIntegrationSpec`:*\n     ```groovy\n     package todoapi\n\n     import grails.test.mixin.integration.Integration\n     import grails.transaction.Rollback\n     import spock.lang.Unroll\n\n     @Integration\n     @Rollback // Rollback transactions after each test method to ensure clean state\n     class TaskRestControllerIntegrationSpec extends BaseIntegrationSpec {\n\n         def taskService // Injected by Grails\n\n         def setup() {\n             // Setup for each feature method, e.g., clear data or create initial data\n             // Ensure data is clean before each test, especially with @Rollback\n             Task.withNewSession { Task.list()*.delete(flush:true) }\n         }\n\n         def \"test creating a new task via REST endpoint\"() {\n             given:\n             def jsonPayload = [title: \"New Task\", description: \"Description\", status: \"PENDING\", priority: \"HIGH\"]\n\n             when:\n             // Simulate a POST request to /api/tasks by directly calling the controller method\n             def controller = new TaskRestController()\n             controller.taskService = taskService // Manually inject service if not auto-wired by @Integration\n             controller.request.method = 'POST'\n             controller.request.json = jsonPayload\n             controller.create()\n\n             then:\n             controller.response.status == 201 // Created\n             def createdTask = Task.findByTitle(\"New Task\")\n             createdTask != null\n             createdTask.description == \"Description\"\n         }\n\n         @Unroll\n         void \"test listing tasks returns #count tasks\"() {\n             given:\n             (1..count).each { new Task(title: \"Task $it\", status: \"PENDING\", priority: \"MEDIUM\").save(flush:true) }\n\n             when:\n             def controller = new TaskRestController()\n             controller.taskService = taskService\n             controller.list()\n\n             then:\n             controller.response.status == 200\n             def tasks = controller.response.json\n             tasks.size() == count\n\n             where:\n             count << [0, 1, 3]\n         }\n\n         // ... other integration tests for TaskRestController endpoints (GET by ID, PUT, DELETE, edge cases)\n     }\n     ```\n\n**3. Test Coverage:**\n   - Ensure comprehensive unit tests for `TaskService` (`grails-app/services/todoapi/TaskService.groovy`) covering all business logic, edge cases, and validations.\n   - Expand unit tests for `TaskController` (`grails-app/controllers/todoapi/TaskController.groovy`) focusing on controller logic, parameter handling, and view rendering.\n   - Create integration tests for `TaskRestController` (`grails-app/controllers/todoapi/TaskRestController.groovy`) covering all REST endpoints (GET, POST, PUT, DELETE) and their respective success and error scenarios, interacting with the database via TestContainers.",
        "testStrategy": "Run `grails test-app` to execute all unit and integration tests. Ensure all tests pass. Review test reports for code coverage (e.g., using a Grails code coverage plugin if configured) and identify areas for improvement. Specifically, verify that TestContainers correctly starts and stops the MySQL container for integration tests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Comprehensive Unit Tests for TaskService",
            "description": "Create `TaskServiceSpec.groovy` in `test/unit/todoapi/` and implement unit tests for all methods in `grails-app/services/todoapi/TaskService.groovy` using Spock Framework. Mock `Task` domain class interactions and cover CRUD operations, status updates, and edge cases.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `test/unit/todoapi/TaskServiceSpec.groovy` extending `grails.test.mixin.TestFor(TaskService)` and `spock.lang.Specification`. Implement feature methods for `listAllTasks()`, `getTaskById(id)`, `createTask(params)`, `updateTask(id, params)`, `deleteTask(id)`, and `updateTaskStatus(id, status)`. Use Spock's mocking capabilities for `Task` domain class methods (e.g., `Task.metaClass.static.list = { -> ... }`).\n<info added on 2025-09-24T21:58:21.137Z>\ntitle: Desenvolver Testes Unitários Abrangentes para TaskService\ndescription: Criar `TaskServiceSpec.groovy` em `test/unit/todoapi/` e implementar testes unitários para todos os métodos em `grails-app/services/todoapi/TaskService.groovy` usando Spock Framework. Mockar interações da classe de domínio `Task` e cobrir operações CRUD, atualizações de status e casos extremos.\n</info added on 2025-09-24T21:58:21.137Z>",
            "testStrategy": "Run `grails test-app unit: TaskService` and ensure all tests pass. Verify high code coverage for `TaskService` methods."
          },
          {
            "id": 2,
            "title": "Develop Comprehensive Unit Tests for TaskController",
            "description": "Create `TaskControllerSpec.groovy` in `test/unit/todoapi/` and implement unit tests for all relevant methods in `grails-app/controllers/todoapi/TaskController.groovy` using Spock Framework. Focus on controller logic, parameter handling, and view rendering.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `test/unit/todoapi/TaskControllerSpec.groovy` extending `grails.test.mixin.TestFor(TaskController)` and `spock.lang.Specification`. Implement feature methods to test actions like `list`, `show`, `create`, `save`, `edit`, `update`, `delete`. Mock the `TaskService` dependency and verify interactions with the service and correct response/view rendering.\n<info added on 2025-09-24T21:58:26.293Z>\nTitle: Desenvolver Testes Unitários Abrangentes para TaskController\nDescription: Criar `TaskControllerSpec.groovy` em `test/unit/todoapi/` e implementar testes unitários para todos os métodos relevantes em `grails-app/controllers/todoapi/TaskController.groovy` usando Spock Framework. Focar na lógica do controlador, manipulação de parâmetros e renderização de views.\n</info added on 2025-09-24T21:58:26.293Z>",
            "testStrategy": "Run `grails test-app unit: TaskController` and ensure all tests pass. Verify adequate code coverage for `TaskController` methods."
          },
          {
            "id": 3,
            "title": "Develop Comprehensive Integration Tests for TaskRestController",
            "description": "Create `TaskRestControllerIntegrationSpec.groovy` in `test/integration/todoapi/` and implement integration tests for all REST endpoints in `grails-app/controllers/todoapi/TaskRestController.groovy`. Utilize the TestContainers setup for a real database interaction.",
            "status": "pending",
            "dependencies": [],
            "details": "Create `test/integration/todoapi/TaskRestControllerIntegrationSpec.groovy` extending the `BaseIntegrationSpec` and annotated with `@Integration` and `@Rollback`. Implement feature methods to test `list`, `show`, `create`, `update`, and `delete` actions via simulated HTTP requests (e.g., by directly calling controller methods with mocked `request` and `response` objects). Ensure tests cover success, error, and edge cases, interacting with the database via the injected `taskService` or directly through `Task` domain class.\n<info added on 2025-09-24T21:58:39.186Z>\nCriar `test/integration/todoapi/TaskRestControllerIntegrationSpec.groovy` estendendo `BaseIntegrationSpec` e anotado com `@Integration` e `@Rollback`. Implementar métodos de feature para testar as ações `list`, `show`, `create`, `update` e `delete` (correspondendo aos endpoints REST em `grails-app/controllers/todoapi/TaskRestController.groovy`) via requisições HTTP simuladas (por exemplo, chamando diretamente os métodos do controlador com objetos `request` e `response` mockados). Garantir que os testes cubram casos de sucesso, erro e casos de borda, interagindo com o banco de dados através do `taskService` injetado ou diretamente pela classe de domínio `Task`, utilizando a configuração do TestContainers para interação real com o banco de dados.\n</info added on 2025-09-24T21:58:39.186Z>",
            "testStrategy": "Run `grails test-app integration: TaskRestController` and ensure all tests pass. Verify that the tests correctly interact with the TestContainers-managed MySQL database and that data persistence and retrieval work as expected."
          }
        ]
      },
      {
        "id": 15,
        "title": "Documentar API REST e Atualizar README do Projeto",
        "description": "Gerar documentação para a API REST do projeto e atualizar o `README.md` com instruções de instalação, configuração e uso.",
        "status": "todo",
        "dependencies": [
          5,
          14
        ],
        "priority": "low",
        "details": "1.  **Documentação da API REST:**\n    *   Gerar documentação para os endpoints da API REST, focando nos controladores como `grails-app/controllers/todoapi/TaskRestController.groovy`.\n    *   Dada a versão do Grails (2.5.6), a documentação pode ser manual, descrevendo os métodos HTTP, URLs, parâmetros de requisição (incluindo formato JSON para o corpo da requisição), e exemplos de respostas.\n    *   A documentação pode ser um arquivo separado (e.g., `API_DOCS.md`) ou integrada de forma concisa no `README.md`.\n2.  **Atualização do `README.md`:**\n    *   Atualizar o arquivo `README.md` na raiz do projeto (`/home/josenerydev/repos/asaas/todo-api/README.md`).\n    *   Incluir instruções claras para o setup do ambiente de desenvolvimento, mencionando o uso do Docker Compose para o MySQL (referenciar `docker-compose.yml` e a configuração do `dataSource` para `development` em `grails-app/conf/DataSource.groovy`).\n    *   Detalhar como rodar a aplicação Grails.\n    *   Adicionar uma seção de 'Uso da API' com exemplos básicos dos principais endpoints (e.g., `GET /api/tasks`, `POST /api/tasks`, `PUT /api/tasks/:id`, `DELETE /api/tasks/:id`, `PATCH /api/tasks/:id/status`), seus métodos e exemplos de requisição/resposta.",
        "testStrategy": "1.  Revisar a documentação da API gerada para garantir clareza, completude e precisão em relação aos endpoints implementados em controladores como `TaskRestController`.\n2.  Verificar o `README.md` para assegurar que as instruções de setup, configuração (especialmente para MySQL via Docker Compose) e uso da API são claras, precisas e fáceis de seguir.",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Configurar Docker Compose com MySQL para Desenvolvimento",
        "description": "Configurar um ambiente de desenvolvimento local usando Docker Compose com um serviço MySQL 8.0, substituindo o H2 como banco de dados padrão para o ambiente `development`.",
        "details": "1.  **Criar `docker-compose.yml`:**\n    *   No diretório raiz do projeto, crie um arquivo `docker-compose.yml`.\n    *   Defina um serviço `db` utilizando a imagem `mysql:8.0`.\n    *   Mapeie a porta `3306` do container para a porta `3306` do host.\n    *   Configure variáveis de ambiente para o MySQL, como `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE`, `MYSQL_USER`, e `MYSQL_PASSWORD`, utilizando valores apropriados para o ambiente de desenvolvimento.\n    *   Configure um volume nomeado (ex: `db_data`) para garantir a persistência dos dados do MySQL.\n    *   Monte um diretório local (ex: `./docker-entrypoint-initdb.d`) para `/docker-entrypoint-initdb.d` no container, para scripts de inicialização do banco de dados.\n2.  **Criar Script de Inicialização do Banco de Dados:**\n    *   Crie o diretório `docker-entrypoint-initdb.d` na raiz do projeto.\n    *   Dentro deste diretório, crie um arquivo `init.sql`.\n    *   Adicione comandos SQL a `init.sql` para criar o schema ou tabelas iniciais, se necessário. Para Grails, `dbCreate` geralmente cuida da criação de tabelas, então este script pode ser usado para dados de seed ou configurações específicas.\n3.  **Atualizar `DataSource.groovy`:**\n    *   Edite o arquivo `grails-app/conf/DataSource.groovy`.\n    *   Localize o bloco de configuração para o ambiente `development`.\n    *   Altere `driverClassName` para `com.mysql.cj.jdbc.Driver`.\n    *   Atualize a `url` para `jdbc:mysql://localhost:3306/<seu_nome_do_banco>?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=UTC` (substitua `<seu_nome_do_banco>` pelo nome definido no `docker-compose.yml`).\n    *   Defina `username` e `password` para corresponder aos valores configurados nas variáveis de ambiente do `docker-compose.yml`.\n    *   Ajuste `dbCreate` conforme a necessidade do desenvolvimento (ex: `update` para migrações automáticas ou `create-drop` para um banco limpo a cada inicialização).\n4.  **Adicionar Dependência do Conector MySQL:**\n    *   No arquivo `grails-app/conf/BuildConfig.groovy`, adicione a dependência `runtime 'mysql:mysql-connector-java:8.0.28'` (ou a versão mais recente compatível) ao bloco `dependencies`.\n5.  **Atualizar `README.md`:**\n    *   Adicione uma seção breve ao `README.md` com instruções sobre como iniciar o ambiente Docker Compose para desenvolvimento.",
        "testStrategy": "1.  Execute `docker-compose up -d` a partir do diretório raiz do projeto para iniciar o serviço MySQL.\n2.  Verifique se o container MySQL foi iniciado com sucesso usando `docker ps`.\n3.  Inicie a aplicação Grails com `grails run-app`.\n4.  Acesse a aplicação no navegador (ex: `http://localhost:8080/`).\n5.  Realize operações CRUD básicas (criar, ler, atualizar, deletar) em uma entidade (ex: `Task`) para garantir que os dados estão sendo persistidos corretamente no MySQL.\n6.  Conecte-se diretamente ao banco de dados MySQL (ex: usando um cliente como DBeaver ou a CLI do MySQL) e verifique a presença e a correção do schema e dos dados.\n7.  Pare a aplicação Grails, em seguida, pare e remova os containers Docker (`docker-compose down`). Reinicie-os (`docker-compose up -d` e `grails run-app`) e confirme que os dados criados anteriormente ainda estão presentes, demonstrando a persistência.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `docker-compose.yml` for MySQL Development Environment",
            "description": "Create a `docker-compose.yml` file in the project root. Define a `db` service using the `mysql:8.0` image. Map container port `3306` to host port `3306`. Configure environment variables such as `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE` (e.g., `todo_dev`), `MYSQL_USER` (e.g., `todo_user`), and `MYSQL_PASSWORD` (e.g., `password`) suitable for development. Set up a named volume (e.g., `db_data`) for data persistence. Mount the local directory `./docker-entrypoint-initdb.d` to `/docker-entrypoint-initdb.d` within the container.",
            "dependencies": [],
            "details": "This subtask establishes the foundational Docker Compose configuration for the MySQL database service. Ensure chosen environment variable values are consistent for subsequent configuration steps.\n<info added on 2025-09-24T22:13:52.444Z>\nCriar o arquivo `docker-compose.yml` na raiz do projeto. Configurar um serviço MySQL 8.0 com variáveis de ambiente para nome do banco, usuário e senha. Expor a porta 3306 para o host. Incluir um volume para persistência de dados e um script de inicialização opcional.\n</info added on 2025-09-24T22:13:52.444Z>",
            "status": "pending",
            "testStrategy": "Run `docker-compose config` in the project root to validate the YAML syntax and configuration. Verify that the service, ports, volumes, and environment variables are correctly defined."
          },
          {
            "id": 2,
            "title": "Implement MySQL Database Initialization Script",
            "description": "Create the directory `docker-entrypoint-initdb.d` in the project root. Inside this directory, create an `init.sql` file. Add any necessary SQL commands to `init.sql` for initial database setup or seeding. For Grails, `dbCreate` typically handles schema creation, so this script can be used for specific seed data or left minimal if `dbCreate` is set to `create-drop` or `update`.",
            "dependencies": [],
            "details": "The `init.sql` script will be executed automatically by MySQL when the container starts for the first time. It's crucial for setting up initial database state if not fully managed by Grails' `dbCreate`.\n<info added on 2025-09-24T21:59:09.443Z>\ntitle: Implementar Script de Inicialização do Banco de Dados MySQL\ndescription: Criar o diretório `docker-entrypoint-initdb.d` na raiz do projeto. Dentro deste diretório, criar um arquivo `init.sql`. Adicionar comandos SQL necessários ao `init.sql` para configuração inicial do banco de dados ou seed data. Para Grails, `dbCreate` normalmente gerencia a criação do schema, então este script pode ser usado para dados de seed específicos ou deixado mínimo se `dbCreate` estiver definido como `create-drop` ou `update`.\n</info added on 2025-09-24T21:59:09.443Z>\n<info added on 2025-09-24T22:14:01.886Z>\ntitle: Implementar Script de Inicialização do Banco de Dados MySQL (`init.sql`)\ndescription: Criar o arquivo `docker-entrypoint-initdb.d/init.sql` na raiz do projeto. Este script será executado automaticamente pelo MySQL quando o container for iniciado pela primeira vez. Incluir comandos SQL para:\n1. Criar o banco de dados `todo_dev` se ele não existir.\n2. Criar o usuário `todo_user` (conforme definido nas variáveis de ambiente do `docker-compose.yml` na subtarefa 16.1) e conceder-lhe todas as permissões no banco de dados `todo_dev`.\n3. Definir configurações básicas do MySQL, como `character_set_server` e `collation_server`, para `utf8mb4` e `utf8mb4_unicode_ci` respectivamente, para garantir compatibilidade com caracteres especiais.\n\nExemplo de conteúdo para `init.sql`:\n```sql\n-- Cria o banco de dados se não existir\nCREATE DATABASE IF NOT EXISTS todo_dev CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n\n-- Cria o usuário e define a senha (substitua 'your_password' pela senha definida em docker-compose.yml para MYSQL_PASSWORD)\nCREATE USER IF NOT EXISTS 'todo_user'@'%' IDENTIFIED BY 'your_password';\n\n-- Concede todas as permissões ao usuário no banco de dados todo_dev\nGRANT ALL PRIVILEGES ON todo_dev.* TO 'todo_user'@'%';\n\n-- Aplica as permissões\nFLUSH PRIVILEGES;\n\n-- Define configurações de charset e collation para o servidor (opcional, mas boa prática)\nSET GLOBAL character_set_server = 'utf8mb4';\nSET GLOBAL collation_server = 'utf8mb4_unicode_ci';\n```\n**Nota:** A senha `your_password` deve ser a mesma definida para `MYSQL_PASSWORD` no `docker-compose.yml`. O `dbCreate` do Grails (a ser configurado na subtarefa 16.3) será responsável pela criação das tabelas. Este script foca na configuração do banco de dados e usuário.\n</info added on 2025-09-24T22:14:01.886Z>",
            "status": "pending",
            "testStrategy": "After completing subtask 1, run `docker-compose up -d db` from the project root. Check `docker logs db` to ensure the MySQL container starts successfully without errors related to the `init.sql` script execution."
          },
          {
            "id": 3,
            "title": "Configure Grails `DataSource.groovy` for MySQL Development",
            "description": "Edit the `grails-app/conf/DataSource.groovy` file. Locate the configuration block for the `development` environment. Change the `driverClassName` to `com.mysql.cj.jdbc.Driver`. Update the `url` to `jdbc:mysql://localhost:3306/todo_dev?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=UTC` (replace `todo_dev` with the actual database name defined in `docker-compose.yml`). Set the `username` and `password` to match the `MYSQL_USER` and `MYSQL_PASSWORD` values configured in `docker-compose.yml`. Adjust `dbCreate` as needed for development (e.g., `update` for migrations or `create-drop` for a clean database on each start).",
            "dependencies": [],
            "details": "This step switches the Grails application's development environment to connect to the new MySQL database. Ensure all connection parameters precisely match the Docker Compose setup.\n<info added on 2025-09-24T21:59:12.583Z>\nTítulo: Configurar Grails `DataSource.groovy` para Desenvolvimento MySQL\nDescrição: Editar o arquivo `grails-app/conf/DataSource.groovy`. Localizar o bloco de configuração para o ambiente `development`. Alterar o `driverClassName` para `com.mysql.cj.jdbc.Driver`. Atualizar a `url` para `jdbc:mysql://localhost:3306/todo_dev?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=UTC` (substituir `todo_dev` pelo nome real do banco de dados definido no `docker-compose.yml`). Definir o `username` e `password` para corresponder aos valores `MYSQL_USER` e `MYSQL_PASSWORD` configurados no `docker-compose.yml`. Ajustar `dbCreate` conforme necessário para desenvolvimento (ex: `update` para migrações ou `create-drop` para um banco limpo a cada inicialização).\n</info added on 2025-09-24T21:59:12.583Z>\n<info added on 2025-09-24T22:14:08.256Z>\nTítulo: Configurar Grails `DataSource.groovy` para Desenvolvimento MySQL\nDescrição: Modificar o arquivo `grails-app/conf/DataSource.groovy` para configurar a conexão com o banco de dados MySQL no ambiente de desenvolvimento. Substituir a configuração H2 existente pela configuração MySQL, incluindo URL de conexão (`jdbc:mysql://localhost:3306/todo_dev`), driver (`com.mysql.cj.jdbc.Driver`), usuário e senha. Manter as configurações de `dbCreate` como `update` para permitir que o Grails gerencie o schema automaticamente.\n</info added on 2025-09-24T22:14:08.256Z>",
            "status": "pending",
            "testStrategy": "After completing subtasks 1 and 2, ensure the MySQL container is running (`docker-compose up -d db`). Then, run `grails run-app`. Observe the console output for any database connection errors and verify the application starts successfully, indicating a connection to MySQL."
          },
          {
            "id": 4,
            "title": "Add MySQL JDBC Connector Dependency",
            "description": "Modify the `grails-app/conf/BuildConfig.groovy` file. Within the `dependencies` block, add the runtime dependency `runtime 'mysql:mysql-connector-java:8.0.28'` (or the latest compatible version for Grails 2.5.6).",
            "dependencies": [],
            "details": "This dependency provides the necessary JDBC driver for the Grails application to communicate with the MySQL database.\n<info added on 2025-09-24T21:59:14.587Z>\nAdicionar Dependência do Conector JDBC MySQL - Modificar o arquivo `grails-app/conf/BuildConfig.groovy`. Dentro do bloco `dependencies`, adicionar a dependência de runtime `runtime 'mysql:mysql-connector-java:8.0.28'` (ou a versão mais recente compatível com Grails 2.5.6).\n</info added on 2025-09-24T21:59:14.587Z>\n<info added on 2025-09-24T22:14:25.555Z>\nAdicionar Dependência do Conector JDBC MySQL - Modificar o arquivo `grails-app/conf/BuildConfig.groovy` para incluir a dependência do conector JDBC MySQL. Adicionar a dependência `mysql:mysql-connector-java` na seção `dependencies` com uma versão compatível (ex: `8.0.33`). Garantir que a dependência seja carregada em tempo de execução (`runtime`) para permitir a conexão com o banco de dados MySQL durante a execução da aplicação.\n</info added on 2025-09-24T22:14:25.555Z>",
            "status": "pending",
            "testStrategy": "Run `grails clean` followed by `grails refresh-dependencies`. Verify that the `mysql-connector-java` JAR file is downloaded and correctly added to the project's dependencies, typically found in the `.grails/2.5.6/projects/<project-name>/plugins/build-test-data-1.0.0.RC1/lib` or similar directory."
          },
          {
            "id": 5,
            "title": "Update `README.md` with Docker Compose Instructions",
            "description": "Add a new section to the `README.md` file in the project root. This section should provide clear instructions on how to start and manage the Docker Compose environment for development. Include commands such as `docker-compose up -d` to start the services, `docker ps` to verify running containers, and any other relevant information for local setup.",
            "dependencies": [],
            "details": "Documenting the new setup ensures that other developers can easily configure their local development environment using Docker Compose and MySQL.\n<info added on 2025-09-24T21:59:16.770Z>\nTítulo: \"Atualizar `README.md` com Instruções do Docker Compose\"\nDescrição: \"Adicionar uma nova seção ao arquivo `README.md` na raiz do projeto. Esta seção deve fornecer instruções claras sobre como iniciar e gerenciar o ambiente Docker Compose para desenvolvimento. Incluir comandos como `docker-compose up -d` para iniciar os serviços, `docker ps` para verificar containers em execução, e qualquer outra informação relevante para configuração local.\"\n</info added on 2025-09-24T21:59:16.770Z>\n<info added on 2025-09-24T22:14:44.169Z>\n<info added on 2025-09-24T21:59:16.770Z>\nTítulo: \"Atualizar `README.md` com Instruções do Docker Compose\"\nDescrição: \"Atualizar o arquivo `README.md` do projeto para incluir instruções detalhadas sobre como usar o Docker Compose para configurar o ambiente de desenvolvimento. Adicionar seções sobre: como iniciar o banco de dados MySQL (`docker-compose up -d db`), como verificar se o container está rodando (`docker ps`), como parar o banco (`docker-compose down`), e como conectar-se ao banco via cliente MySQL. Incluir também informações sobre as variáveis de ambiente configuradas e a estrutura de diretórios do projeto.\"\n</info added on 2025-09-24T21:59:16.770Z>\n</info added on 2025-09-24T22:14:44.169Z>",
            "status": "pending",
            "testStrategy": "Review the `README.md` file to ensure the new section is present, the instructions are clear, accurate, and easy to follow for someone setting up the project for the first time."
          }
        ]
      },
      {
        "id": 17,
        "title": "Configurar Ambiente de Testes com Spock e TestContainers",
        "description": "Configurar o ambiente de testes do projeto com Spock Framework para testes unitários e TestContainers para testes de integração, incluindo dependências, estrutura de diretórios, DataSource e classes base.",
        "details": "Esta tarefa envolve a configuração completa do ambiente de testes para o projeto Grails 2.5.6, utilizando o Spock Framework para testes unitários e o TestContainers para gerenciar instâncias de banco de dados MySQL para testes de integração.\n\n**1. Configuração de Dependências em `grails-app/conf/BuildConfig.groovy`:**\n   Adicione as seguintes dependências no bloco `dependencies` dentro do escopo `test`:\n   ```groovy\n   // grails-app/conf/BuildConfig.groovy\n   dependencies {\n       // ... outras dependências existentes\n\n       // Dependências para Spock Framework\n       test \"org.spockframework:spock-core:0.7-groovy-2.0\" // Compatível com Groovy 2.0/Grails 2.5.x\n       test \"cglib:cglib-nodep:2.2\" // Necessário para Spock\n\n       // Dependências para TestContainers (versão compatível com Java 7/8 e Grails 2.5.x)\n       test \"org.testcontainers:testcontainers:1.15.3\"\n       test \"org.testcontainers:mysql:1.15.3\"\n   }\n   ```\n\n**2. Estrutura de Diretórios para Testes:**\n   Garanta que os seguintes diretórios existam para organizar os testes:\n   *   `grails-app/test/unit` (para testes unitários)\n   *   `grails-app/test/integration` (para testes de integração)\n   Grails geralmente cria esses diretórios por padrão, mas verifique sua existência.\n\n**3. Configuração do DataSource para Testes de Integração com TestContainers:**\n   Modifique `grails-app/conf/DataSource.groovy` para configurar o `dataSource` para o ambiente `test`. O TestContainers irá sobrescrever as propriedades de conexão (URL, usuário, senha) dinamicamente.\n   ```groovy\n   // grails-app/conf/DataSource.groovy\n   environments {\n       test {\n           dataSource {\n               dbCreate = \"create-drop\" // Garante um banco de dados limpo para cada execução de teste\n               // As propriedades abaixo serão sobrescritas pelo TestContainers via System Properties\n               url = System.getProperty(\"test.datasource.url\", \"jdbc:mysql://localhost:3306/testdb\")\n               username = System.getProperty(\"test.datasource.username\", \"testuser\")\n               password = System.getProperty(\"test.datasource.password\", \"testpassword\")\n               driverClassName = \"com.mysql.jdbc.Driver\"\n           }\n       }\n   }\n   ```\n\n**4. Criação de Classes Base para Testes:**\n\n   *   **Classe Base para Testes Unitários (`grails-app/test/unit/todoapi/BaseUnitTestSpec.groovy`):**\n       Crie uma classe base para testes unitários que estenda `spock.lang.Specification`. Esta classe pode ser usada para adicionar configurações comuns ou utilitários para todos os testes unitários.\n       ```groovy\n       package todoapi\n\n       import spock.lang.Specification\n\n       /**\n        * Classe base para testes unitários Spock. Estenda esta classe para testes\n        * que não exigem um banco de dados em execução ou ambiente Grails completo.\n        */\n       abstract class BaseUnitTestSpec extends Specification {\n           // Adicione métodos de setup/teardown comuns ou utilitários aqui, se necessário\n       }\n       ```\n\n   *   **Classe Base para Testes de Integração (`grails-app/test/integration/todoapi/BaseIntegrationTestSpec.groovy`):**\n       Crie uma classe base para testes de integração que estenda `spock.lang.Specification` e gerencie o ciclo de vida de um container MySQL via TestContainers. Esta classe será responsável por iniciar e parar o container e configurar as propriedades do DataSource.\n       ```groovy\n       package todoapi\n\n       import grails.test.mixin.integration.Integration\n       import grails.util.Environment\n       import spock.lang.Shared\n       import spock.lang.Specification\n       import org.testcontainers.containers.MySQLContainer\n       import org.testcontainers.utility.DockerImageName\n\n       /**\n        * Classe base para testes de integração Spock usando TestContainers para MySQL.\n        * Esta classe gerencia o ciclo de vida de um container MySQL para testes de integração.\n        */\n       @Integration // Marca a classe como um teste de integração Grails\n       abstract class BaseIntegrationTestSpec extends Specification {\n\n           @Shared\n           MySQLContainer mysql = new MySQLContainer(DockerImageName.parse(\"mysql:8.0\"))\n\n           def setupSpec() {\n               // Inicia o container MySQL apenas no ambiente de teste\n               if (Environment.current == Environment.TEST) {\n                   mysql.start()\n                   // Define System Properties que serão lidas pelo DataSource.groovy\n                   System.setProperty(\"test.datasource.url\", mysql.getJdbcUrl())\n                   System.setProperty(\"test.datasource.username\", mysql.getUsername())\n                   System.setProperty(\"test.datasource.password\", mysql.getPassword())\n               }\n           }\n\n           def cleanupSpec() {\n               // Para o container MySQL após todos os testes da especificação\n               if (Environment.current == Environment.TEST) {\n                   mysql.stop()\n                   // Limpa as System Properties para evitar efeitos colaterais\n                   System.clearProperty(\"test.datasource.url\")\n                   System.clearProperty(\"test.datasource.username\")\n                   System.clearProperty(\"test.datasource.password\")\n               }\n           }\n       }\n       ```\n\n**Considerações:**\n*   A versão do TestContainers (`1.15.3`) foi escolhida por ser mais provável de ser compatível com o ambiente Grails 2.5.6 (Java 7/8). Versões mais recentes do TestContainers podem exigir Java 11+.\n*   A configuração do `DataSource.groovy` para ler `System.getProperty` garante que o TestContainers possa injetar as credenciais do banco de dados dinamicamente.\n*   O `dbCreate = \"create-drop\"` no ambiente `test` assegura que o esquema do banco de dados seja recriado para cada execução de teste, proporcionando isolamento.",
        "testStrategy": "1.  Execute `grails clean` e `grails compile` para garantir que as novas dependências sejam baixadas e o projeto seja compilado.\n2.  Crie um teste unitário simples (ex: `grails-app/test/unit/todoapi/ExampleUnitTestSpec.groovy` estendendo `BaseUnitTestSpec`) e execute `grails test-app unit:` para verificar se o Spock está configurado corretamente.\n3.  Crie um teste de integração simples (ex: `grails-app/test/integration/todoapi/ExampleIntegrationTestSpec.groovy` estendendo `BaseIntegrationTestSpec`) que tente salvar e recuperar um objeto de domínio. Execute `grails test-app integration:`.\n4.  Durante a execução dos testes de integração, observe os logs para confirmar que o TestContainers inicia e para o container MySQL. Verifique se o teste de integração consegue se conectar ao banco de dados do container e realizar operações básicas (ex: criar uma tabela, inserir dados).\n5.  Certifique-se de que todos os testes passem e que não haja erros relacionados à configuração do ambiente de teste ou conexão com o banco de dados.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Adicionar Dependências de Teste (Spock e TestContainers)",
            "description": "Adicionar as dependências do Spock Framework e TestContainers (incluindo o módulo MySQL) ao escopo 'test' no arquivo `grails-app/conf/BuildConfig.groovy`.",
            "dependencies": [],
            "details": "No arquivo `grails-app/conf/BuildConfig.groovy`, adicione as seguintes dependências dentro do bloco `dependencies` e escopo `test`:\n```groovy\ntest \"org.spockframework:spock-core:0.7-groovy-2.0\"\ntest \"cglib:cglib-nodep:2.2\"\ntest \"org.testcontainers:testcontainers:1.15.3\"\ntest \"org.testcontainers:mysql:1.15.3\"\n```\n<info added on 2025-09-24T21:59:54.006Z>\nVerifique a existência dos diretórios `grails-app/test/unit` e `grails-app/test/integration`.\n*   O diretório `grails-app/test/unit` é destinado a testes unitários com Spock Framework.\n*   O diretório `grails-app/test/integration` é destinado a testes de integração com Spock Framework e TestContainers.\nA análise do projeto (`Glob: grails-app/test/**/*`) confirma que esses diretórios já existem e contêm `Specs` Spock, como `TaskControllerSpec.groovy` e `TaskServiceSpec.groovy`, indicando que a estrutura básica para testes já está configurada.\n</info added on 2025-09-24T21:59:54.006Z>\n<info added on 2025-09-24T22:15:11.898Z>\nA seção inicial desta subtarefa, que detalha a adição de dependências ao `grails-app/conf/BuildConfig.groovy`, refere-se à implementação da subtarefa 17.1. Para esta subtarefa (17.2), o foco principal é a verificação e, se necessário, a criação da estrutura de diretórios de teste, conforme detalhado a seguir.\n</info added on 2025-09-24T22:15:11.898Z>",
            "status": "pending",
            "testStrategy": "Execute `grails clean` e `grails compile` para garantir que as novas dependências sejam baixadas e o projeto seja compilado sem erros."
          },
          {
            "id": 2,
            "title": "Verificar e Criar Estrutura de Diretórios de Teste",
            "description": "Garantir que os diretórios `grails-app/test/unit` e `grails-app/test/integration` existam para organizar os testes unitários e de integração, respectivamente.",
            "dependencies": [],
            "details": "Verifique a existência dos diretórios `grails-app/test/unit` e `grails-app/test/integration`. Se algum deles não existir, crie-o manualmente. Grails geralmente cria esses diretórios por padrão, mas a verificação é importante.\n<info added on 2025-09-24T22:00:19.569Z>\nComo a análise do projeto revelou que os diretórios `grails-app/test/unit` e `grails-app/test/integration` não existem atualmente, é necessário criá-los manualmente. Execute os seguintes comandos na raiz do projeto para garantir a estrutura correta:\n```bash\nmkdir -p grails-app/test/unit\nmkdir -p grails-app/test/integration\n```\nEsta etapa é crucial para organizar os testes unitários e de integração que serão desenvolvidos nas próximas subtarefas, seguindo a convenção de diretórios do Grails.\n</info added on 2025-09-24T22:00:19.569Z>\n<info added on 2025-09-24T22:15:31.313Z>\nVerificar se os diretórios `grails-app/test/unit` e `grails-app/test/integration` existem no projeto. Se não existirem, criá-los. O diretório `unit` é destinado a testes unitários com Spock Framework, enquanto o diretório `integration` é para testes de integração com Spock Framework e TestContainers. Garantir que a estrutura esteja pronta para receber as classes de teste base e os testes específicos do projeto.\n</info added on 2025-09-24T22:15:31.313Z>",
            "status": "pending",
            "testStrategy": "Use o comando `ls -F grails-app/test/` para confirmar a presença dos diretórios `unit/` e `integration/`."
          },
          {
            "id": 3,
            "title": "Configurar DataSource para Ambiente de Teste com TestContainers",
            "description": "Modificar o arquivo `grails-app/conf/DataSource.groovy` para configurar o `dataSource` do ambiente `test`, permitindo que o TestContainers sobrescreva as propriedades de conexão dinamicamente.",
            "dependencies": [
              "17.1"
            ],
            "details": "No arquivo `grails-app/conf/DataSource.groovy`, adicione ou modifique o bloco `test` dentro de `environments`:\n```groovy\nenvironments {\n    test {\n        dataSource {\n            dbCreate = \"create-drop\"\n            url = System.getProperty(\"test.datasource.url\", \"jdbc:mysql://localhost:3306/testdb\")\n            username = System.getProperty(\"test.datasource.username\", \"testuser\")\n            password = System.getProperty(\"test.datasource.password\", \"testpassword\")\n            driverClassName = \"com.mysql.jdbc.Driver\"\n        }\n    }\n}\n```\n<info added on 2025-09-24T22:00:47.744Z>\nNo arquivo `grails-app/conf/DataSource.groovy`, localize o bloco `environments`. Se o bloco `test` já existir (provavelmente configurado para H2 em memória), substitua-o ou modifique-o para que corresponda à configuração fornecida. Caso contrário, adicione o bloco `test` dentro de `environments` conforme o exemplo.\n\n**Explicação das Propriedades:**\n\n*   **`dbCreate = \"create-drop\"`**: Esta configuração é crucial para o ambiente de testes. Ela garante que o esquema do banco de dados seja recriado do zero a cada vez que os testes são executados, proporcionando um ambiente limpo e isolado para cada suíte de testes.\n*   **`url`, `username`, `password` com `System.getProperty()`**: As propriedades `url`, `username` e `password` são configuradas para ler seus valores de propriedades do sistema (`test.datasource.url`, `test.datasource.username`, `test.datasource.password`). Isso permite que o TestContainers, ao iniciar um contêiner MySQL para os testes, injete dinamicamente as credenciais de conexão geradas por ele, sobrescrevendo os valores padrão (`jdbc:mysql://localhost:3306/testdb`, `testuser`, `testpassword`).\n*   **`driverClassName = \"com.mysql.jdbc.Driver\"`**: É importante que o driver especificado aqui seja o `com.mysql.jdbc.Driver`, que é o driver JDBC para MySQL. Certifique-se de que a dependência `mysql:mysql-connector-java` esteja presente no escopo `runtime` ou `test` do seu `grails-app/conf/BuildConfig.groovy` (conforme já abordado na **Tarefa 1** e **Tarefa 17.1**).\n\nEsta configuração prepara o ambiente de testes para se conectar a uma instância de banco de dados MySQL gerenciada pelo TestContainers, garantindo flexibilidade e isolamento nos testes de integração.\n</info added on 2025-09-24T22:00:47.744Z>\n<info added on 2025-09-24T22:15:48.091Z>\nModificar o arquivo `grails-app/conf/DataSource.groovy` para configurar o ambiente de teste (`test`) para usar TestContainers com MySQL. Configurar a URL de conexão, usuário e senha para serem definidos via System Properties (ex: `System.getProperty(\"test.datasource.url\")`), permitindo que o TestContainers configure dinamicamente a conexão com o container MySQL durante a execução dos testes de integração.\n</info added on 2025-09-24T22:15:48.091Z>\n<info added on 2025-09-24T22:18:02.683Z>\nDependencies: 1\n</info added on 2025-09-24T22:18:02.683Z>",
            "status": "pending",
            "testStrategy": "Esta configuração será testada implicitamente quando os testes de integração forem executados, pois o TestContainers tentará injetar as propriedades de conexão."
          },
          {
            "id": 4,
            "title": "Criar Classe Base para Testes Unitários (BaseUnitTestSpec)",
            "description": "Criar a classe base `BaseUnitTestSpec` para testes unitários, estendendo `spock.lang.Specification`, no diretório `grails-app/test/unit/todoapi/`.",
            "dependencies": [
              "17.1",
              "17.2"
            ],
            "details": "Crie o arquivo `grails-app/test/unit/todoapi/BaseUnitTestSpec.groovy` com o seguinte conteúdo:\n```groovy\npackage todoapi\n\nimport spock.lang.Specification\n\nabstract class BaseUnitTestSpec extends Specification {\n    // Adicione métodos de setup/teardown comuns ou utilitários aqui, se necessário\n}\n```\n<info added on 2025-09-24T22:01:08.132Z>\n\"Criar Classe Base para Testes Unitários (BaseUnitTestSpec)\" - \"Criar a classe base `BaseUnitTestSpec` para testes unitários, estendendo `spock.lang.Specification`, no diretório `grails-app/test/unit/todoapi/`.\"\n</info added on 2025-09-24T22:01:08.132Z>\n<info added on 2025-09-24T22:16:10.801Z>\nCrie o arquivo `grails-app/test/unit/todoapi/BaseUnitTestSpec.groovy` com o seguinte conteúdo:\n```groovy\npackage todoapi\n\nimport spock.lang.Specification\n\n/**\n * Classe base abstrata para todos os testes unitários do projeto.\n *\n * Esta classe estende `spock.lang.Specification` e deve ser utilizada como\n * ponto de partida para a criação de novos testes unitários.\n *\n * Propósito:\n * - Fornecer um local centralizado para métodos de setup e teardown comuns\n *   a todos os testes unitários.\n * - Adicionar utilitários ou extensões Spock que sejam úteis em múltiplos testes.\n * - Garantir consistência na estrutura dos testes unitários.\n *\n * Como utilizar:\n * Basta estender esta classe ao criar um novo teste unitário. Exemplo:\n * ```groovy\n * class MyServiceSpec extends BaseUnitTestSpec {\n *     // ... seus testes aqui ...\n * }\n * ```\n */\nabstract class BaseUnitTestSpec extends Specification {\n    // Adicione métodos de setup/teardown comuns ou utilitários aqui, se necessário.\n    // Por exemplo:\n    // def setup() {\n    //     // Executado antes de cada feature method\n    // }\n    //\n    // def cleanup() {\n    //     // Executado depois de cada feature method\n    // }\n    //\n    // def setupSpec() {\n    //     // Executado uma vez antes de todos os feature methods na especificação\n    // }\n    //\n    // def cleanupSpec() {\n    //     // Executado uma vez depois de todos os feature methods na especificação\n    // }\n}\n```\n<info added on 2025-09-24T22:01:08.132Z>\n\"Criar Classe Base para Testes Unitários (BaseUnitTestSpec)\" - \"Criar o arquivo `grails-app/test/unit/todoapi/BaseUnitTestSpec.groovy` que estende `spock.lang.Specification`. Esta classe servirá como base para todos os testes unitários do projeto, fornecendo métodos comuns de setup/teardown e utilitários compartilhados. Incluir comentários explicativos sobre o propósito da classe e como utilizá-la nos testes unitários.\"\n</info added on 2025-09-24T22:01:08.132Z>\n</info added on 2025-09-24T22:16:10.801Z>\n<info added on 2025-09-24T22:18:55.749Z>\n[\n  1,\n  2\n]\n</info added on 2025-09-24T22:18:55.749Z>",
            "status": "pending",
            "testStrategy": "Crie um teste unitário simples (ex: `grails-app/test/unit/todoapi/ExampleUnitTestSpec.groovy`) que estenda `BaseUnitTestSpec` e execute `grails test-app unit:` para verificar se a classe é reconhecida e o teste pode ser executado."
          },
          {
            "id": 5,
            "title": "Criar Classe Base para Testes de Integração (BaseIntegrationTestSpec)",
            "description": "Criar a classe base `BaseIntegrationTestSpec` para testes de integração, que estende `spock.lang.Specification` e gerencia o ciclo de vida de um container MySQL via TestContainers, no diretório `grails-app/test/integration/todoapi/`.",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3"
            ],
            "details": "Crie o arquivo `grails-app/test/integration/todoapi/BaseIntegrationTestSpec.groovy` com o seguinte conteúdo:\n```groovy\npackage todoapi\n\nimport grails.test.mixin.integration.Integration\nimport grails.util.Environment\nimport spock.lang.Shared\nimport spock.lang.Specification\nimport org.testcontainers.containers.MySQLContainer\nimport org.testcontainers.utility.DockerImageName\n\n@Integration\nabstract class BaseIntegrationTestSpec extends Specification {\n\n    @Shared\n    MySQLContainer mysql = new MySQLContainer(DockerImageName.parse(\"mysql:8.0\"))\n\n    def setupSpec() {\n        if (Environment.current == Environment.TEST) {\n            mysql.start()\n            System.setProperty(\"test.datasource.url\", mysql.getJdbcUrl())\n            System.setProperty(\"test.datasource.username\", mysql.getUsername())\n            System.setProperty(\"test.datasource.password\", mysql.getPassword())\n        }\n    }\n\n    def cleanupSpec() {\n        if (Environment.current == Environment.TEST) {\n            mysql.stop()\n            System.clearProperty(\"test.datasource.url\")\n            System.clearProperty(\"test.datasource.username\")\n            System.clearProperty(\"test.datasource.password\")\n        }\n    }\n}\n```\n<info added on 2025-09-24T22:01:10.488Z>\ntitle: Criar Classe Base para Testes de Integração (BaseIntegrationTestSpec)\ndescription: Criar a classe base `BaseIntegrationTestSpec` para testes de integração, que estende `spock.lang.Specification` e gerencia o ciclo de vida de um container MySQL via TestContainers, no diretório `grails-app/test/integration/todoapi/`.\n</info added on 2025-09-24T22:01:10.488Z>\n<info added on 2025-09-24T22:16:31.882Z>\ntitle: Criar Classe Base para Testes de Integração (BaseIntegrationTestSpec)\ndescription: Criar o arquivo `grails-app/test/integration/todoapi/BaseIntegrationTestSpec.groovy` que estende `spock.lang.Specification` e é anotada com `@Integration`. Esta classe gerenciará o ciclo de vida de um container MySQL usando TestContainers, configurando as System Properties necessárias para o DataSource e fornecendo métodos de setup/teardown para os testes de integração. Incluir comentários detalhados sobre o funcionamento do TestContainers e como utilizá-la nos testes de integração.\n```groovy\npackage todoapi\n\nimport grails.test.mixin.integration.Integration\nimport grails.util.Environment\nimport spock.lang.Shared\nimport spock.lang.Specification\nimport org.testcontainers.containers.MySQLContainer\nimport org.testcontainers.utility.DockerImageName\n\n/**\n * Classe base abstrata para testes de integração que utilizam Spock e TestContainers.\n * Esta classe configura e gerencia o ciclo de vida de um container MySQL\n * para cada execução de suite de testes de integração, garantindo um ambiente\n * de banco de dados limpo e isolado para os testes.\n */\n@Integration // Anotação do Grails que marca esta classe como um teste de integração.\n             // Isso garante que o contexto completo da aplicação Grails seja carregado\n             // para os testes que estendem esta classe, incluindo injeção de serviços,\n             // controladores, etc.\nabstract class BaseIntegrationTestSpec extends Specification {\n\n    /**\n     * Declaração de um container MySQL usando TestContainers.\n     * A anotação `@Shared` do Spock garante que esta instância do container\n     * seja criada e compartilhada por todos os métodos de teste dentro de uma\n     * mesma classe de especificação que estende BaseIntegrationTestSpec.\n     * Isso otimiza o tempo de execução, pois o container é iniciado apenas uma vez\n     * para toda a suite de testes que o utiliza, e não para cada método de teste.\n     *\n     * `DockerImageName.parse(\"mysql:8.0\")` especifica a imagem Docker a ser usada.\n     * Certifique-se de que o Docker esteja em execução no ambiente de teste para\n     * que o TestContainers possa provisionar o container.\n     */\n    @Shared\n    MySQLContainer mysql = new MySQLContainer(DockerImageName.parse(\"mysql:8.0\"))\n\n    /**\n     * Método executado uma única vez antes de todos os testes na especificação.\n     * Ele é responsável por iniciar o container MySQL e configurar as propriedades\n     * do sistema que o Grails usará para conectar ao banco de dados.\n     */\n    def setupSpec() {\n        // Verifica se o ambiente atual é de teste. Isso é uma boa prática para\n        // garantir que o TestContainers só seja ativado em ambientes de teste,\n        // evitando interferências em outros contextos (ex: desenvolvimento, produção).\n        if (Environment.current == Environment.TEST) {\n            mysql.start() // Inicia o container MySQL.\n            // Configura as propriedades do sistema com os detalhes de conexão\n            // do container MySQL. O Grails (ou qualquer framework JDBC) pode\n            // então usar estas propriedades para configurar seu DataSource.\n            // Estas propriedades sobrescrevem as configurações padrão do DataSource\n            // definidas em DataSource.groovy para o ambiente de teste.\n            // Para Grails 2.x, as propriedades do sistema para o DataSource\n            // no ambiente de teste geralmente seguem o padrão \"test.datasource.<propriedade>\".\n            // Verifique seu DataSource.groovy para confirmar os nomes exatos das propriedades.\n            System.setProperty(\"test.datasource.url\", mysql.getJdbcUrl())\n            System.setProperty(\"test.datasource.username\", mysql.getUsername())\n            System.setProperty(\"test.datasource.password\", mysql.getPassword())\n        }\n    }\n\n    /**\n     * Método executado uma única vez após todos os testes na especificação.\n     * Ele é responsável por parar o container MySQL e limpar as propriedades\n     * do sistema configuradas em `setupSpec()`.\n     */\n    def cleanupSpec() {\n        // Garante que a limpeza ocorra apenas no ambiente de teste.\n        if (Environment.current == Environment.TEST) {\n            mysql.stop() // Para e remove o container MySQL, liberando recursos.\n            // Limpa as propriedades do sistema para evitar vazamentos ou\n            // interferências em testes subsequentes ou em outras partes da aplicação.\n            System.clearProperty(\"test.datasource.url\")\n            System.clearProperty(\"test.datasource.username\")\n            System.clearProperty(\"test.datasource.password\")\n        }\n    }\n\n    // Como usar esta classe em um teste de integração:\n    // Para criar um teste de integração que utilize um banco de dados MySQL\n    // gerenciado pelo TestContainers, basta estender esta classe.\n    //\n    // Exemplo de uso em um teste de integração para um serviço:\n    //\n    // package todoapi\n    //\n    // import grails.transaction.Transactional\n    // import todoapi.Task\n    //\n    // // A anotação @Transactional é útil para garantir que cada método de teste\n    // // seja executado dentro de uma transação que é revertida ao final,\n    // // garantindo um estado de banco de dados limpo para cada teste individual.\n    // @Transactional\n    // class TaskServiceIntegrationSpec extends BaseIntegrationTestSpec {\n    //\n    //     // O Grails injetará automaticamente o serviço aqui, pois estamos em um\n    //     // teste de integração (@Integration na classe base).\n    //     def taskService\n    //\n    //     def \"deve criar uma nova tarefa no banco de dados\"() {\n    //         when: \"Uma nova tarefa é criada através do serviço\"\n    //         def task = taskService.createTask(new Task(title: \"Test Task\", description: \"Description\"))\n    //\n    //         then: \"A tarefa deve ser persistida e o contador de tarefas deve ser 1\"\n    //         task != null\n    //         task.id != null\n    //         Task.count() == 1 // Verifica diretamente no banco de dados\n    //     }\n    //\n    //     def \"deve listar todas as tarefas existentes\"() {\n    //         setup: \"Duas tarefas são criadas\"\n    //         taskService.createTask(new Task(title: \"Task 1\"))\n    //         taskService.createTask(new Task(title: \"Task 2\"))\n    //\n    //         when: \"O serviço é chamado para listar todas as tarefas\"\n    //         def tasks = taskService.listAllTasks()\n    //\n    //         then: \"Duas tarefas devem ser retornadas\"\n    //         tasks.size() == 2\n    //         tasks.any { it.title == \"Task 1\" }\n    //         tasks.any { it.title == \"Task 2\" }\n    //     }\n    // }\n    //\n    // Ao estender `BaseIntegrationTestSpec`, cada classe de teste de integração\n    // terá um container MySQL dedicado (compartilhado por todos os métodos daquela\n    // *especificação*), garantindo isolamento e um estado inicial conhecido\n    // para o banco de dados para cada suite de testes.\n}\n```\n</info added on 2025-09-24T22:16:31.882Z>\n<info added on 2025-09-24T22:19:01.149Z>\nDependencies: 1, 2, 3\n</info added on 2025-09-24T22:19:01.149Z>",
            "status": "pending",
            "testStrategy": "Crie um teste de integração simples (ex: `grails-app/test/integration/todoapi/ExampleIntegrationTestSpec.groovy`) que estenda `BaseIntegrationTestSpec` e execute `grails test-app integration:` para verificar se o container MySQL é iniciado e parado corretamente, e se o teste consegue se conectar ao banco de dados."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-24T21:36:03.445Z",
      "updated": "2025-09-24T22:17:39.998Z",
      "description": "Tasks for master context"
    }
  }
}