# .cursor/commands/implement_test_case.md

## Comando: Implement Test Case

**Objetivo:** materializar casos de teste definidos em um documento de especificação (ex.: `.test-cases/<ClassName>/Test-Cases-<ClassName>.md`) em código-fonte de testes, criando/atualizando arquivos no projeto de testes, de forma idempotente e rastreável.

### Parâmetros
- `class_name` (obrigatório): Nome exato da classe alvo (ex.: `ReceivableAnticipationRequesterAnalysisService`).
- `spec_path` (opcional): Caminho para o arquivo Markdown de casos. **Default:** `.test-cases/{{class_name}}/Test-Cases-{{class_name}}.md`.
- `case_ids` (opcional): Lista de IDs (`["TC001","TC002"]`) ou string (`"TC001,TC003"`) para selecionar casos específicos. **Default:** `"*"` (todos).
- `stack` (opcional): Forçar stack (`"dotnet"` | `"groovy"`). **Default:** auto (lê `.diagnostics/stack/stack.json`).
- `test_project_root` (opcional): Raiz do projeto de testes. **Default (dotnet):** `tests/` ou diretórios com `*.csproj` de teste. **Default (groovy):** `src/test/groovy`.
- `mocks` (opcional): Preferência de mocks (`"Moq" | "NSubstitute" | "Mockito" | "WireMock" | "None"`). **Default:** auto a partir de `.diagnostics/tests/test_tooling.json`.
- `assertions` (opcional): Biblioteca de asserções (`"FluentAssertions" | "AssertJ" | "Spock" | "None"`). **Default:** auto.
- `overwrite_strategy` (opcional): `"by_id"` (atualiza blocos marcados), `"section"` (regrava seção do método), `"file"` (regrava arquivo). **Default:** `"by_id"`.
- `dry_run` (opcional): `true` para apenas gerar patches e não gravar. **Default:** `false`.
- `touch_source_on_missing_contract` (opcional): `true` para gerar *stubs* mínimos no código de produção quando o método não existir. **Default:** `false`.

### Saídas (arquivos/pastas em inglês)
- Arquivos de teste atualizados/criados em `test_project_root` (ex.: `tests/{{class_name}}Tests.cs` ou `src/test/groovy/.../{{class_name}}Spec.groovy`).
- `.generated/patches/implement_test_case-{{timestamp}}.diff` (pré-visualização/registro).
- `.generated/logs/implement_test_case.log` (diagnóstico).
- Atualizações opcionais em `.diagnostics/tests/pending.yaml` se lacunas forem encontradas (ex.: falta de framework de teste, mocks não disponíveis).

---

## Instruções para o Agent

1. **Resolver Stack e Tooling**
   - Carregar `.diagnostics/stack/stack.json` e `.diagnostics/tests/test_tooling.json`. Se `stack` vier por parâmetro, priorizar.
   - Validar presença de framework de teste e mocks/assertions preferidos; se ausentes, registrar em `.diagnostics/tests/pending.yaml`.

2. **Ler e Interpretar a Especificação**
   - Abrir `spec_path` (ou falhar com mensagem curta se inexistente).
   - Para cada seção `## N. Testes para \`<method signature>\``, mapear os itens:
     - **IDs** iniciando com `TC` (`- **TC001**: ...`), coletando título/descrição.
     - Classificar por "Cenários de Sucesso", "Cenários de Falha" e "Edge Cases".
   - Se `case_ids != "*"`, filtrar pelos IDs informados.

3. **Gerar Estrutura de Arquivo de Teste**
   - **.NET (xUnit)**:
     - Destino padrão: `tests/{{class_name}}Tests.cs` (ou manter arquivo existente).
     - Namespace: derivar do projeto ou usar `{{RootNamespace}}.Tests` se disponível; senão `Tests`.
     - Imports conforme `mocks`/`assertions`.
   - **Groovy/Grails (Spock)**:
     - Destino padrão: `src/test/groovy/{{packagePath}}/{{class_name}}Spec.groovy` (deduzir `package` do código/estrutura).

4. **Materializar Casos (AAA) com Blocos Idempotentes**
   - Para cada caso selecionado, inserir/atualizar bloco demarcado:
     - Início: `// <auto-generated implement_test_case: {{TCID}}>` (ou `//` → `/* */` conforme linguagem).
     - Fim: `// </auto-generated implement_test_case: {{TCID}}>`
   - Gerar nome do teste com padrão:
     - **.NET:** `<Method>_Should_<Expected>_When_<Condition>_{{TCID}}`
     - **Spock:** `def "{{title}} ({{TCID}})"() { ... }`
   - Preencher **Arrange / Act / Assert** com *placeholders* derivados do texto:
     - Detectar insumos (ex.: IDs nulos, coleções vazias) e pré-configurar *mocks*.
     - Anotar `TODO:` claros para o desenvolvedor completar dados de domínio.

5. **Opcional: Stubs de Código de Produção**
   - Se `touch_source_on_missing_contract=true` e o método alvo não existir:
     - Criar *stub* mínimo (assinatura e `throw new NotImplementedException()` / `UnsupportedOperationException`), protegido por comentário `// <auto-generated implement_test_case: stub>`.

6. **Persistência e Patches**
   - Se `dry_run=true`, não gravar arquivos de teste; apenas gerar `.generated/patches/*.diff`.
   - Caso contrário, aplicar alterações e registrar diff em `.generated/patches`.
   - Logar decisões em `.generated/logs/implement_test_case.log`.

7. **Atualizações de Diagnóstico**
   - Se bibliotecas requeridas pelo template não existirem, criar entrada em `.diagnostics/tests/pending.yaml` com `severity` apropriada e recomendação objetiva (ex.: adicionar `FluentAssertions`/`Moq`/`spock-core`).

---

## Convenções por Stack

### .NET (xUnit)

**Destino e Convenções**
- Arquivo-alvo: `tests/{{class_name}}Tests.cs` (ou arquivo existente que contenha a *test class*).
- Usings condicionais:
  - `using Xunit;`
  - `using FluentAssertions;` (se `assertions == FluentAssertions`)
  - `using Moq;` | `using NSubstitute;` (conforme `mocks`)

**Template da Classe de Teste**
```csharp
// <auto-generated implement_test_case: header>
using System;
using Xunit;
{{#if useFluent}}using FluentAssertions;{{/if}}
{{#if useMoq}}using Moq;{{/if}}
{{#if useNSub}}using NSubstitute;{{/if}}

namespace {{namespace}}.Tests;

public class {{class_name}}Tests
{
    {{#if useMoq}}// EX: private readonly Mock<IDependency> _dep = new();{{/if}}
    {{#if useNSub}}// EX: private readonly IDependency _dep = Substitute.For<IDependency>();{{/if}}

    private {{class_name}} CreateSut()
    {
        // TODO: construir SUT com dependências
        return new {{class_name}}(/* deps */);
    }

    // Casos serão inseridos abaixo (blocos auto-generated por TCID)
}
// </auto-generated implement_test_case: header>
